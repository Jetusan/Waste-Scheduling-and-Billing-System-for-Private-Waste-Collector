const { pool } = require('../config/db');
const fs = require('fs');
const path = require('path');

// Attempt to load WSBS logo for PDF reports
let wsbsLogoBase64 = '';
try {
  const logoPath = path.join(__dirname, '..', '..', 'admin', 'src', 'assets', 'images', 'LOGO.png');
  const logoBuffer = fs.readFileSync(logoPath);
  wsbsLogoBase64 = logoBuffer.toString('base64');
} catch (error) {
  console.warn('âš ï¸ Unable to load WSBS logo for reports:', error.message);
}

class ReportController {
  // ðŸ“‹ GET ALL REPORTS
  static async getAllReports(req, res) {
    try {
      const query = `
        SELECT * FROM reports 
        ORDER BY created_at DESC
      `;
      const result = await pool.query(query);
      res.json(result.rows);
    } catch (error) {
      console.error('Error fetching reports:', error);
      res.status(500).json({ error: 'Failed to fetch reports', details: error.message });
    }
  }

  // ðŸ—‘ï¸ DELETE REPORT
  static async deleteReport(req, res) {
    try {
      const { id } = req.params;
      const query = `DELETE FROM reports WHERE report_id = $1`;
      await pool.query(query, [id]);
      res.json({ message: 'Report deleted successfully' });
    } catch (error) {
      console.error('Error deleting report:', error);
      res.status(500).json({ error: 'Failed to delete report', details: error.message });
    }
  }

  // ðŸ“¥ DOWNLOAD REPORT (Fixed with PDF Export)
  static async downloadReport(req, res) {
    try {
      const { id } = req.params;
      const { format = 'json' } = req.query; // Support format parameter
      
      const query = `SELECT * FROM reports WHERE report_id = $1`;
      const result = await pool.query(query, [id]);
      
      if (result.rows.length === 0) {
        return res.status(404).json({ error: 'Report not found' });
      }
      
      const report = result.rows[0];
      
      // Fix JSON parsing issue
      let reportData;
      try {
        // Handle both string and object data types
        if (typeof report.data === 'string') {
          reportData = JSON.parse(report.data);
        } else if (typeof report.data === 'object' && report.data !== null) {
          reportData = report.data;
        } else {
          reportData = {};
        }
      } catch (parseError) {
        console.error('JSON parse error:', parseError);
        reportData = {};
      }

      const reportResponse = {
        type: report.type,
        generated_by: report.generated_by,
        date: report.date,
        period: report.period,
        data: reportData,
        report_id: report.report_id,
        start_date: report.start_date,
        end_date: report.end_date,
        status: report.status
      };

      // If PDF format is requested, generate PDF
      if (format === 'pdf') {
        return await ReportController.generatePDF(reportResponse, res);
      }

      // Default: return JSON
      res.json(reportResponse);
      
    } catch (error) {
      console.error('Error downloading report:', error);
      res.status(500).json({ error: 'Failed to download report', details: error.message });
    }
  }

  // ðŸ”„ GENERATE REPORT
  static async generateReport(req, res) {
    try {
      const { type, period, generated_by, start_date, end_date, filters = {} } = req.body;

      console.log('=== REPORT GENERATION REQUEST ===');
      console.log('Type:', type);
      console.log('Generated by:', generated_by);
      console.log('Start date:', start_date);
      console.log('End date:', end_date);
      console.log('Filters:', JSON.stringify(filters, null, 2));

      // Validate required fields
      if (!type) {
        return res.status(400).json({ error: 'Report type is required' });
      }
      if (!period) {
        return res.status(400).json({ error: 'Period is required' });
      }
      if (!generated_by) {
        return res.status(400).json({ error: 'Generated by field is required' });
      }

      let reportData = {};
      let reportType = type;

      // Generate different types of reports based on simplified structure
      switch (type) {
        case 'waste-collection':
        case 'collection':
        case 'regular-pickup':
          console.log('Generating unified collection report (regular + special pickups)...');
          reportData = await ReportController.generateUnifiedCollectionReport(filters, start_date, end_date);
          reportType = 'collection-report';
          break;
        case 'financial-summary':
        case 'billing-payment':
        case 'billing':
          console.log('Generating financial report...');
          reportData = await ReportController.generateFinancialReport(filters, start_date, end_date);
          reportType = 'billing-report';
          break;
        default:
          console.log('Unknown report type, defaulting to collection report...');
          reportData = await ReportController.generateUnifiedCollectionReport(filters, start_date, end_date);
          reportType = 'collection-report';
      }

      console.log('Report generation successful, storing in database...');

      // Store the report in the database
      const insertQuery = `
        INSERT INTO reports (type, period, generated_by, date, status, data, start_date, end_date)
        VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
        RETURNING *
      `;

      const reportResult = await pool.query(insertQuery, [
        reportType,
        period,
        generated_by,
        new Date().toISOString().split('T')[0],
        'Completed',
        JSON.stringify(reportData),
        start_date,
        end_date
      ]);

      console.log('Report stored successfully:', reportResult.rows[0].report_id);

      res.json({
        message: 'Report generated successfully',
        report: reportResult.rows[0],
        status: 'Completed'
      });

    } catch (error) {
      console.error('=== REPORT GENERATION ERROR ===');
      console.error('Error type:', error.constructor.name);
      console.error('Error message:', error.message);
      console.error('Error stack:', error.stack);
      console.error('Error details:', error);

      res.status(500).json({
        error: 'Failed to generate report',
        details: error.message,
        type: error.constructor.name,
        stack: error.stack
      });
    }
  }

  // ðŸ’° BILLING REPORTS
  static async generateBillingReport(req, res) {
    try {
      const { startDate, endDate, planType, status, barangay } = req.query;
      
      let query = `
        SELECT 
          DATE_TRUNC('month', i.generated_date) as billing_month,
          sp.plan_name,
          sp.price,
          b.barangay_name,
          COUNT(i.invoice_id) as total_invoices,
          SUM(i.amount) as total_billed,
          SUM(CASE WHEN i.status = 'paid' THEN i.amount ELSE 0 END) as total_collected,
          SUM(CASE WHEN i.status = 'unpaid' THEN i.amount ELSE 0 END) as outstanding,
          SUM(CASE WHEN i.status = 'overdue' THEN i.amount ELSE 0 END) as overdue_amount,
          ROUND((SUM(CASE WHEN i.status = 'paid' THEN i.amount ELSE 0 END) * 100.0 / 
                 NULLIF(SUM(i.amount), 0)), 2) as collection_rate,
          COUNT(CASE WHEN i.status = 'paid' THEN 1 END) as paid_count,
          COUNT(CASE WHEN i.status = 'unpaid' THEN 1 END) as unpaid_count,
          COUNT(CASE WHEN i.status = 'overdue' THEN 1 END) as overdue_count
        FROM invoices i
        JOIN customer_subscriptions cs ON i.subscription_id = cs.subscription_id
        JOIN subscription_plans sp ON cs.plan_id = sp.plan_id
        JOIN users u ON cs.user_id = u.user_id
        LEFT JOIN addresses a ON u.address_id = a.address_id
        LEFT JOIN barangays b ON a.barangay_id = b.barangay_id
        WHERE 1=1
      `;
      
      const params = [];
      let paramCount = 0;
      
      if (startDate && endDate) {
        paramCount += 2;
        query += ` AND i.generated_date BETWEEN $${paramCount-1} AND $${paramCount}`;
        params.push(startDate, endDate);
      }
      
      if (planType) {
        paramCount++;
        query += ` AND sp.plan_id = $${paramCount}::integer`;
        params.push(planType);
      }
      
      if (status && status !== 'all') {
        paramCount++;
        query += ` AND i.status = $${paramCount}`;
        params.push(status);
      }
      
      if (barangay) {
        paramCount++;
        query += ` AND b.barangay_id = $${paramCount}::integer`;
        params.push(barangay);
      }
      
      query += `
        GROUP BY DATE_TRUNC('month', i.generated_date), sp.plan_name, sp.price, b.barangay_name
        ORDER BY billing_month DESC, total_billed DESC
      `;
      
      const result = await pool.query(query, params);
      
      // Calculate financial summary
      const financialSummary = {
        totalBilled: result.rows.reduce((sum, row) => sum + parseFloat(row.total_billed || 0), 0),
        totalCollected: result.rows.reduce((sum, row) => sum + parseFloat(row.total_collected || 0), 0),
        totalOutstanding: result.rows.reduce((sum, row) => sum + parseFloat(row.outstanding || 0), 0),
        totalOverdue: result.rows.reduce((sum, row) => sum + parseFloat(row.overdue_amount || 0), 0),
        overallCollectionRate: 0,
        invoiceStats: {
          total: result.rows.reduce((sum, row) => sum + parseInt(row.total_invoices || 0), 0),
          paid: result.rows.reduce((sum, row) => sum + parseInt(row.paid_count || 0), 0),
          unpaid: result.rows.reduce((sum, row) => sum + parseInt(row.unpaid_count || 0), 0),
          overdue: result.rows.reduce((sum, row) => sum + parseInt(row.overdue_count || 0), 0)
        },
        topPerformingPlans: {},
        worstPerformingBarangays: {}
      };
      
      // Calculate overall collection rate
      if (financialSummary.totalBilled > 0) {
        financialSummary.overallCollectionRate = 
          ((financialSummary.totalCollected / financialSummary.totalBilled) * 100).toFixed(2);
      }
      
      // Group performance by plan and barangay
      result.rows.forEach(row => {
        // By plan
        if (!financialSummary.topPerformingPlans[row.plan_name]) {
          financialSummary.topPerformingPlans[row.plan_name] = {
            totalBilled: 0,
            collectionRate: 0,
            invoiceCount: 0
          };
        }
        financialSummary.topPerformingPlans[row.plan_name].totalBilled += parseFloat(row.total_billed || 0);
        financialSummary.topPerformingPlans[row.plan_name].invoiceCount += parseInt(row.total_invoices || 0);
        
        // By barangay (for worst performers - high outstanding)
        if (row.barangay_name && parseFloat(row.outstanding || 0) > 0) {
          if (!financialSummary.worstPerformingBarangays[row.barangay_name]) {
            financialSummary.worstPerformingBarangays[row.barangay_name] = 0;
          }
          financialSummary.worstPerformingBarangays[row.barangay_name] += parseFloat(row.outstanding || 0);
        }
      });
      
      res.json({
        type: 'billing-report',
        period: `${startDate || 'all'} to ${endDate || 'all'}`,
        financialSummary,
        monthlyBreakdown: result.rows,
        generatedAt: new Date().toISOString()
      });
      
    } catch (error) {
      console.error('Error generating billing report:', error);
      res.status(500).json({ error: 'Failed to generate billing report', details: error.message });
    }
  }

  // ðŸ“‹ COMBINED DASHBOARD REPORT
  static async generateDashboardReport(req, res) {
    try {
      const { period = '30' } = req.query; // Last 30 days by default
      
      const endDate = new Date();
      const startDate = new Date();
      startDate.setDate(startDate.getDate() - parseInt(period));
      
      // Get collection performance
      const collectionQuery = `
        SELECT 
          COUNT(*) as total_schedules,
          COUNT(CASE WHEN cr.status = 'completed' THEN 1 END) as completed,
          COUNT(CASE WHEN cr.status = 'missed' THEN 1 END) as missed,
          COUNT(CASE WHEN cr.status = 'partial' THEN 1 END) as partial
        FROM collection_schedules cs
        LEFT JOIN collection_results cr ON cs.schedule_id = cr.schedule_id
        WHERE cs.created_at BETWEEN $1 AND $2
      `;
      
      // Get billing performance
      const billingQuery = `
        SELECT 
          COUNT(*) as total_invoices,
          SUM(amount) as total_amount,
          SUM(CASE WHEN status = 'paid' THEN amount ELSE 0 END) as paid_amount,
          COUNT(CASE WHEN status = 'paid' THEN 1 END) as paid_count
        FROM invoices
        WHERE generated_date BETWEEN $1 AND $2
      `;
      
      // Get user activity
      const userQuery = `
        SELECT 
          r.role_name,
          COUNT(u.user_id) as user_count
        FROM users u
        JOIN roles r ON u.role_id = r.role_id
        WHERE u.created_at BETWEEN $1 AND $2 OR u.updated_at BETWEEN $1 AND $2
        GROUP BY r.role_name
      `;
      
      const [collectionResult, billingResult, userResult] = await Promise.all([
        pool.query(collectionQuery, [startDate, endDate]),
        pool.query(billingQuery, [startDate, endDate]),
        pool.query(userQuery, [startDate, endDate])
      ]);
      
      const dashboard = {
        period: `Last ${period} days`,
        collection: collectionResult.rows[0] || {},
        billing: billingResult.rows[0] || {},
        users: userResult.rows,
        generatedAt: new Date().toISOString()
      };
      
      // Calculate rates
      if (dashboard.collection.total_schedules > 0) {
        dashboard.collection.completion_rate = 
          ((dashboard.collection.completed / dashboard.collection.total_schedules) * 100).toFixed(2);
      }
      
      if (dashboard.billing.total_amount > 0) {
        dashboard.billing.collection_rate = 
          ((dashboard.billing.paid_amount / dashboard.billing.total_amount) * 100).toFixed(2);
      }
      
      res.json({
        type: 'dashboard-report',
        dashboard,
        generatedAt: new Date().toISOString()
      });
      
    } catch (error) {
      console.error('Error generating dashboard report:', error);
      res.status(500).json({ error: 'Failed to generate dashboard report', details: error.message });
    }
  }

  // ðŸŽ¯ PERFORMANCE INSIGHTS
  static async generateInsightsReport(req, res) {
    try {
      // Get top performing barangays
      const topBarangaysQuery = `
        SELECT 
          b.barangay_name,
          COUNT(DISTINCT cs.subscription_id) as active_subscriptions,
          COUNT(CASE WHEN i.status = 'paid' THEN 1 END) as paid_invoices,
          COUNT(i.invoice_id) as total_invoices,
          ROUND((COUNT(CASE WHEN i.status = 'paid' THEN 1 END) * 100.0 / 
                 NULLIF(COUNT(i.invoice_id), 0)), 2) as payment_rate
        FROM barangays b
        LEFT JOIN addresses a ON b.barangay_id = a.barangay_id
        LEFT JOIN users u ON a.address_id = u.address_id
        LEFT JOIN customer_subscriptions cs ON u.user_id = cs.user_id
        LEFT JOIN invoices i ON cs.subscription_id = i.subscription_id
        GROUP BY b.barangay_id, b.barangay_name
        HAVING COUNT(i.invoice_id) > 0
        ORDER BY payment_rate DESC, active_subscriptions DESC
        LIMIT 10
      `;
      
      // Get collection efficiency by collector
      const collectorEfficiencyQuery = `
        SELECT 
          u.username as collector_name,
          COUNT(cr.result_id) as total_assignments,
          COUNT(CASE WHEN cr.status = 'completed' THEN 1 END) as completed_collections,
          ROUND((COUNT(CASE WHEN cr.status = 'completed' THEN 1 END) * 100.0 / 
                 NULLIF(COUNT(cr.result_id), 0)), 2) as efficiency_rate
        FROM collectors c
        JOIN users u ON c.user_id = u.user_id
        LEFT JOIN collection_results cr ON c.collector_id = cr.collector_id
        WHERE c.status = 'active'
        GROUP BY c.collector_id, u.username
        ORDER BY efficiency_rate DESC, completed_collections DESC
      `;
      
      const [topBarangays, collectorEfficiency] = await Promise.all([
        pool.query(topBarangaysQuery),
        pool.query(collectorEfficiencyQuery)
      ]);
      
      res.json({
        type: 'insights-report',
        insights: {
          topPerformingBarangays: topBarangays.rows,
          collectorEfficiency: collectorEfficiency.rows,
          recommendations: [
            {
              category: 'Collection',
              suggestion: 'Focus on training collectors with efficiency rates below 80%',
              priority: 'High'
            },
            {
              category: 'Billing',
              suggestion: 'Implement targeted collection campaigns in underperforming barangays',
              priority: 'Medium'
            },
            {
              category: 'Operations',
              suggestion: 'Consider increasing frequency in high-performing areas',
              priority: 'Low'
            }
          ]
        },
        generatedAt: new Date().toISOString()
      });
      
    } catch (error) {
      console.error('Error generating insights report:', error);
      res.status(500).json({ error: 'Failed to generate insights report', details: error.message });
    }
  }

  // ðŸ“… REGULAR PICKUP REPORT GENERATOR (FIXED - Uses Real Collection Data)
  static async generateWasteCollectionReport(filters = {}, startDate, endDate) {
    try {
      console.log('=== WASTE COLLECTION REPORT ===');
      console.log('Filters:', filters);
      console.log('Start date:', startDate);
      console.log('End date:', endDate);

      // Validate dates
      const validStartDate = startDate && !isNaN(Date.parse(startDate)) ? startDate : '1900-01-01';
      const validEndDate = endDate && !isNaN(Date.parse(endDate)) ? endDate : '2100-12-31';

      // FIXED: Query actual collection data from collection_stop_events
      // Start with a simple query to avoid JOIN type issues
      let query = `
        SELECT
          cse.id,
          cse.action as status,
          cse.stop_id,
          cse.schedule_id,
          cse.user_id,
          cse.collector_id,
          cse.notes,
          cse.amount,
          cse.created_at,
          DATE(cse.created_at) as collection_date,
          -- Get user and barangay info (with safe joins)
          COALESCE(u.username, 'Unknown User') as resident_name,
          COALESCE(b.barangay_name, 'Unknown Barangay') as barangay_name,
          COALESCE(b.barangay_id, 0) as barangay_id,
          -- Get collector info (with safe joins)
          COALESCE(uc.username, 'Unknown Collector') as collector_name,
          -- Get schedule info if available (with safe joins)
          COALESCE(cs.waste_type, 'Mixed Waste') as waste_type,
          COALESCE(cs.schedule_date, 
            CASE EXTRACT(DOW FROM cse.created_at)
              WHEN 0 THEN 'Sunday'
              WHEN 1 THEN 'Monday' 
              WHEN 2 THEN 'Tuesday'
              WHEN 3 THEN 'Wednesday'
              WHEN 4 THEN 'Thursday'
              WHEN 5 THEN 'Friday'
              WHEN 6 THEN 'Saturday'
            END
          ) as schedule_date,
          COALESCE(cs.time_range, 
            CASE 
              WHEN EXTRACT(HOUR FROM cse.created_at) BETWEEN 6 AND 11 THEN '06:00-12:00'
              WHEN EXTRACT(HOUR FROM cse.created_at) BETWEEN 12 AND 17 THEN '12:00-18:00'
              ELSE '18:00-06:00'
            END
          ) as time_range
        FROM collection_stop_events cse
        LEFT JOIN users u ON CAST(cse.user_id AS INTEGER) = CAST(u.user_id AS INTEGER)
        LEFT JOIN addresses a ON CAST(u.address_id AS INTEGER) = CAST(a.address_id AS INTEGER)
        LEFT JOIN barangays b ON CAST(a.barangay_id AS INTEGER) = CAST(b.barangay_id AS INTEGER)
        LEFT JOIN collectors c ON CAST(cse.collector_id AS INTEGER) = CAST(c.collector_id AS INTEGER)
        LEFT JOIN users uc ON CAST(c.user_id AS INTEGER) = CAST(uc.user_id AS INTEGER)
        LEFT JOIN collection_schedules cs ON CAST(cse.schedule_id AS TEXT) = CAST(cs.schedule_id AS TEXT)
        WHERE 1=1
      `;

      const params = [];
      let paramCount = 0;

      // Apply date filter using actual collection dates
      if (validStartDate && validEndDate) {
        paramCount += 2;
        query += ` AND DATE(cse.created_at) BETWEEN CAST($${paramCount-1} AS DATE) AND CAST($${paramCount} AS DATE)`;
        params.push(validStartDate, validEndDate);
      }

      // Apply barangay filter
      if (filters.barangay && filters.barangay !== '' && filters.barangay !== 'all') {
        console.log('Applying barangay filter:', filters.barangay, 'Type:', typeof filters.barangay);
        // Validate that it's a valid integer
        const barangayId = parseInt(filters.barangay);
        if (!isNaN(barangayId) && barangayId > 0) {
          paramCount++;
          query += ` AND b.barangay_id = $${paramCount}::integer`;
          params.push(barangayId);
        }
      }

      // Apply status filter
      if (filters.status && filters.status !== 'all' && filters.status !== '') {
        console.log('Applying status filter:', filters.status);
        
        // Map frontend status values to database action values
        let dbAction = filters.status;
        switch (filters.status) {
          case 'completed':
          case 'today_completed':
          case 'ontime':
            dbAction = 'collected';
            break;
          case 'missed':
            dbAction = 'missed';
            break;
          case 'pending':
          case 'in_progress':
            dbAction = 'pending';
            break;
          case 'cancelled':
            dbAction = 'cancelled';
            break;
          case 'late':
            // For late collections, we still want collected items but with additional time filtering
            dbAction = 'collected';
            break;
          default:
            dbAction = filters.status;
        }
        
        paramCount++;
        query += ` AND cse.action = $${paramCount}`;
        params.push(dbAction);
      }

      // Apply collector filter
      if (filters.collector && filters.collector !== '' && filters.collector !== 'all') {
        console.log('Applying collector filter:', filters.collector, 'Type:', typeof filters.collector);
        // Validate that it's a valid integer
        const collectorId = parseInt(filters.collector);
        if (!isNaN(collectorId) && collectorId > 0) {
          paramCount++;
          query += ` AND c.collector_id = $${paramCount}::integer`;
          params.push(collectorId);
        }
      }

      // Apply waste type filter
      if (filters.wasteType && filters.wasteType !== '' && filters.wasteType !== 'all') {
        console.log('Applying waste type filter:', filters.wasteType);
        paramCount++;
        query += ` AND cs.waste_type ILIKE $${paramCount}`;
        params.push(`%${filters.wasteType}%`);
      }

      query += ` ORDER BY cse.created_at DESC`;

      console.log('Executing query:', query);
      console.log('Query params:', params);

      const result = await pool.query(query, params);
      console.log('Query result rows:', result.rows.length);

      // Analytics query for waste types and collection performance
      const analyticsQuery = `
        SELECT
          COALESCE(cs.waste_type, 'Mixed Waste') as waste_type,
          COUNT(*) as total_collections,
          COUNT(CASE WHEN cse.action = 'collected' THEN 1 END) as completed_count,
          COUNT(CASE WHEN cse.action = 'missed' THEN 1 END) as missed_count,
          ROUND(COUNT(CASE WHEN cse.action = 'collected' THEN 1 END) * 100.0 / COUNT(*), 2) as completion_rate
        FROM collection_stop_events cse
        LEFT JOIN collection_schedules cs ON CAST(cse.schedule_id AS TEXT) = CAST(cs.schedule_id AS TEXT)
        WHERE DATE(cse.created_at) BETWEEN CAST($1 AS DATE) AND CAST($2 AS DATE)
        GROUP BY cs.waste_type
        ORDER BY total_collections DESC
      `;

      const analyticsResult = await pool.query(analyticsQuery, [validStartDate, validEndDate]);
      console.log('Analytics result:', analyticsResult.rows);

      // Calculate summary based on real collection data
      const summary = {
        totalSchedules: result.rows.length, // Changed from totalCollections to match PDF
        totalCollections: result.rows.length,
        completed: result.rows.filter(r => r.status === 'collected').length,
        missed: result.rows.filter(r => r.status === 'missed').length,
        pending: result.rows.filter(r => r.status === 'pending').length,
        completionRate: 0,
        wasteTypesHandled: new Set(result.rows.map(r => r.waste_type).filter(Boolean)).size,
        barangaysCovered: new Set(result.rows.map(r => r.barangay_name).filter(Boolean)).size,
        collectorsInvolved: new Set(result.rows.map(r => r.collector_id).filter(Boolean)).size,
        totalWasteAmount: result.rows.reduce((sum, row) => sum + parseFloat(row.amount || 0), 0)
      };

      if (summary.totalCollections > 0) {
        summary.completionRate = ((summary.completed / summary.totalCollections) * 100).toFixed(2);
      }

      // Waste type breakdown with percentages - FIXED
      const wasteTypeBreakdown = {};
      const totalCollections = result.rows.length;
      
      // First pass: count occurrences
      result.rows.forEach(row => {
        const wasteType = row.waste_type || 'Mixed Waste';
        wasteTypeBreakdown[wasteType] = (wasteTypeBreakdown[wasteType] || 0) + 1;
      });

      // Second pass: convert to proper format with count and percentage
      const formattedWasteTypeBreakdown = {};
      Object.keys(wasteTypeBreakdown).forEach(wasteType => {
        const count = wasteTypeBreakdown[wasteType];
        formattedWasteTypeBreakdown[wasteType] = {
          count: count,
          percentage: totalCollections > 0 ? parseFloat(((count / totalCollections) * 100).toFixed(1)) : 0
        };
      });
      
      // Use the formatted version
      const finalWasteTypeBreakdown = formattedWasteTypeBreakdown;

      // Barangay breakdown
      const barangayBreakdown = {};
      result.rows.forEach(row => {
        const barangay = row.barangay_name || 'Unknown';
        barangayBreakdown[barangay] = (barangayBreakdown[barangay] || 0) + 1;
      });

      // Collector performance breakdown
      const collectorBreakdown = {};
      result.rows.forEach(row => {
        const collector = row.collector_name || `Collector ${row.collector_id}` || 'Unknown';
        if (!collectorBreakdown[collector]) {
          collectorBreakdown[collector] = { total: 0, completed: 0, missed: 0 };
        }
        collectorBreakdown[collector].total++;
        if (row.status === 'collected') collectorBreakdown[collector].completed++;
        if (row.status === 'missed') collectorBreakdown[collector].missed++;
      });

      const finalResult = {
        reportType: 'regular-pickup',
        summary,
        collections: result.rows,
        wasteTypeBreakdown: finalWasteTypeBreakdown,
        barangayBreakdown,
        collectorBreakdown,
        analytics: analyticsResult.rows,
        filters: filters,
        dateRange: { startDate: validStartDate, endDate: validEndDate },
        generatedAt: new Date().toISOString()
      };

      console.log('Waste collection report generated successfully');
      return finalResult;

    } catch (error) {
      console.error('=== WASTE COLLECTION REPORT ERROR ===');
      console.error('Error type:', error.constructor.name);
      console.error('Error message:', error.message);
      console.error('Error stack:', error.stack);
      throw error;
    }
  }

  // ðŸ’° BILLING/PAYMENT REPORT GENERATOR (REAL DATA)
  static async generateFinancialReport(filters = {}, startDate, endDate) {
    try {
      console.log('=== FINANCIAL REPORT ===');
      console.log('Filters:', filters);
      console.log('Start date:', startDate);
      console.log('End date:', endDate);

      // Validate dates
      const validStartDate = startDate && !isNaN(Date.parse(startDate)) ? startDate : '1900-01-01';
      const validEndDate = endDate && !isNaN(Date.parse(endDate)) ? endDate : '2100-12-31';

      // FIXED: Enhanced billing query with real data and safe joins
      let query = `
        SELECT 
          i.invoice_id,
          i.invoice_number,
          i.subscription_id,
          i.amount,
          i.status as invoice_status,
          i.generated_date,
          i.due_date,
          i.late_fees,
          i.notes,
          i.created_at,
          i.updated_at,
          DATE(i.generated_date) as billing_date,
          -- Calculate payment status
          CASE 
            WHEN i.status = 'paid' THEN 'Paid'
            WHEN i.status = 'unpaid' AND i.due_date < CURRENT_DATE THEN 'Overdue'
            WHEN i.status = 'unpaid' THEN 'Pending'
            ELSE UPPER(SUBSTRING(i.status, 1, 1)) || SUBSTRING(i.status, 2)
          END as payment_status_display,
          -- Get subscription and user info (with safe joins)
          COALESCE(cs.user_id, 0) as user_id,
          COALESCE(u.username, 'Unknown User') as resident_name,
          COALESCE(sp.plan_name, 'Unknown Plan') as plan_name,
          COALESCE(sp.price, 0) as plan_price,
          COALESCE(b.barangay_name, 'Unknown Barangay') as barangay_name,
          COALESCE(b.barangay_id, 0) as barangay_id
        FROM invoices i
        LEFT JOIN customer_subscriptions cs ON CAST(i.subscription_id AS INTEGER) = CAST(cs.subscription_id AS INTEGER)
        LEFT JOIN subscription_plans sp ON CAST(cs.plan_id AS INTEGER) = CAST(sp.plan_id AS INTEGER)
        LEFT JOIN users u ON CAST(cs.user_id AS INTEGER) = CAST(u.user_id AS INTEGER)
        LEFT JOIN addresses a ON CAST(u.address_id AS INTEGER) = CAST(a.address_id AS INTEGER)
        LEFT JOIN barangays b ON CAST(a.barangay_id AS INTEGER) = CAST(b.barangay_id AS INTEGER)
        WHERE 1=1
      `;

      const params = [];
      let paramCount = 0;

      // Apply date filters using actual invoice dates
      if (validStartDate && validEndDate) {
        paramCount += 2;
        query += ` AND DATE(i.generated_date) BETWEEN CAST($${paramCount-1} AS DATE) AND CAST($${paramCount} AS DATE)`;
        params.push(validStartDate, validEndDate);
      }

      // Apply barangay filter
      if (filters.barangay && filters.barangay !== '' && filters.barangay !== 'all') {
        console.log('Applying barangay filter to billing report:', filters.barangay, 'Type:', typeof filters.barangay);
        const barangayId = parseInt(filters.barangay);
        if (!isNaN(barangayId) && barangayId > 0) {
          paramCount++;
          query += ` AND b.barangay_id = $${paramCount}::integer`;
          params.push(barangayId);
        }
      }

      // Apply plan filter
      if (filters.plan && filters.plan !== '' && filters.plan !== 'all') {
        console.log('Applying plan filter to billing report:', filters.plan, 'Type:', typeof filters.plan);
        const planId = parseInt(filters.plan);
        if (!isNaN(planId) && planId > 0) {
          paramCount++;
          query += ` AND sp.plan_id = $${paramCount}::integer`;
          params.push(planId);
        }
      }

      // Apply status filter
      if (filters.status && filters.status !== 'all' && filters.status !== '') {
        console.log('Applying status filter to billing report:', filters.status);
        
        // Map frontend status values to database status values
        let dbStatus = filters.status;
        switch (filters.status) {
          case 'paid_ontime':
          case 'paid_late':
            dbStatus = 'paid';
            break;
          case 'high_value':
          case 'low_value':
            // These will be handled by amount filters instead
            break;
          default:
            dbStatus = filters.status;
        }
        
        if (dbStatus && !['high_value', 'low_value', 'paid_ontime', 'paid_late'].includes(filters.status)) {
          paramCount++;
          query += ` AND i.status = $${paramCount}`;
          params.push(dbStatus);
        }
      }

      // Apply payment method filter
      if (filters.paymentMethod && filters.paymentMethod !== 'all' && filters.paymentMethod !== '') {
        console.log('Applying payment method filter to billing report:', filters.paymentMethod);
        paramCount++;
        query += ` AND i.payment_method = $${paramCount}`;
        params.push(filters.paymentMethod);
      }
      
      // Apply amount filters for high/low value
      if (filters.status === 'high_value' || (filters.minAmount && parseFloat(filters.minAmount) >= 1000)) {
        paramCount++;
        query += ` AND i.amount >= $${paramCount}`;
        params.push(filters.minAmount || 1000);
      }
      
      if (filters.status === 'low_value' || (filters.maxAmount && parseFloat(filters.maxAmount) <= 500)) {
        paramCount++;
        query += ` AND i.amount <= $${paramCount}`;
        params.push(filters.maxAmount || 500);
      }
      
      // Apply custom amount range filters
      if (filters.minAmount && filters.status !== 'high_value' && filters.status !== 'low_value') {
        const minAmount = parseFloat(filters.minAmount);
        if (!isNaN(minAmount) && minAmount > 0) {
          paramCount++;
          query += ` AND i.amount >= $${paramCount}`;
          params.push(minAmount);
        }
      }
      
      if (filters.maxAmount && filters.status !== 'high_value' && filters.status !== 'low_value') {
        const maxAmount = parseFloat(filters.maxAmount);
        if (!isNaN(maxAmount) && maxAmount > 0) {
          paramCount++;
          query += ` AND i.amount <= $${paramCount}`;
          params.push(maxAmount);
        }
      }

      // Apply waste type filter (join with collection schedules to get waste type context)
      if (filters.wasteType && filters.wasteType !== '' && filters.wasteType !== 'all') {
        console.log('Applying waste type filter to billing report:', filters.wasteType);
        // Add join with collection_schedules to filter by waste type
        query = query.replace('WHERE 1=1', `
          LEFT JOIN collection_stop_events cse ON cse.user_id = cs.user_id 
            AND DATE(cse.created_at) BETWEEN DATE(i.generated_date) - INTERVAL '7 days' AND DATE(i.generated_date) + INTERVAL '7 days'
          LEFT JOIN collection_schedules sched ON CAST(cse.schedule_id AS TEXT) = CAST(sched.schedule_id AS TEXT)
          WHERE 1=1
        `);
        paramCount++;
        query += ` AND sched.waste_type ILIKE $${paramCount}`;
        params.push(`%${filters.wasteType}%`);
      }

      query += ` ORDER BY i.generated_date DESC`;

      console.log('Executing financial query:', query);
      console.log('Query params:', params);

      const result = await pool.query(query, params);
      console.log('Financial query result rows:', result.rows.length);

      // Calculate summary
      const invoices = result.rows;
      const summary = {
        totalInvoices: invoices.length,
        totalAmount: invoices.reduce((sum, inv) => sum + parseFloat(inv.amount || 0), 0),
        paidInvoices: invoices.filter(inv => inv.invoice_status === 'paid').length,
        unpaidInvoices: invoices.filter(inv => inv.invoice_status === 'unpaid').length,
        overdueInvoices: invoices.filter(inv => inv.invoice_status === 'overdue').length,
        paidAmount: invoices.filter(inv => inv.invoice_status === 'paid').reduce((sum, inv) => sum + parseFloat(inv.amount || 0), 0),
        unpaidAmount: invoices.filter(inv => inv.invoice_status === 'unpaid').reduce((sum, inv) => sum + parseFloat(inv.amount || 0), 0),
        collectionRate: 0
      };

      if (summary.totalAmount > 0) {
        summary.collectionRate = ((summary.paidAmount / summary.totalAmount) * 100).toFixed(2);
      }

      // Plan breakdown
      const planBreakdown = {};
      invoices.forEach(invoice => {
        const plan = invoice.plan_name || 'Unknown';
        if (!planBreakdown[plan]) {
          planBreakdown[plan] = { count: 0, totalAmount: 0, paidAmount: 0 };
        }
        planBreakdown[plan].count++;
        planBreakdown[plan].totalAmount += parseFloat(invoice.amount || 0);
        if (invoice.invoice_status === 'paid') {
          planBreakdown[plan].paidAmount += parseFloat(invoice.amount || 0);
        }
      });

      // Get user balance summaries from ledger
      const ledgerSummaryQuery = `
        WITH user_balances AS (
          SELECT 
            i.user_id,
            u.username,
            b.barangay_name,
            SUM(i.amount) as total_billed,
            COALESCE(SUM(p.amount), 0) as total_paid,
            SUM(i.amount) - COALESCE(SUM(p.amount), 0) as current_balance,
            COUNT(i.invoice_id) as total_invoices,
            COUNT(CASE WHEN i.status = 'paid' THEN 1 END) as paid_invoices,
            COUNT(CASE WHEN i.status = 'overdue' THEN 1 END) as overdue_invoices
          FROM invoices i
          LEFT JOIN payments p ON p.invoice_id = i.invoice_id
          LEFT JOIN users u ON i.user_id = u.user_id
          LEFT JOIN addresses a ON u.address_id = a.address_id
          LEFT JOIN barangays b ON a.barangay_id = b.barangay_id
          WHERE DATE(i.generated_date) BETWEEN $1 AND $2
          GROUP BY i.user_id, u.username, b.barangay_name
        )
        SELECT 
          COUNT(*) as total_users,
          SUM(current_balance) as total_outstanding,
          COUNT(CASE WHEN current_balance > 0 THEN 1 END) as users_with_balance,
          COUNT(CASE WHEN current_balance > 1000 THEN 1 END) as high_balance_users,
          AVG(current_balance) as avg_balance,
          MAX(current_balance) as max_balance,
          MIN(current_balance) as min_balance
        FROM user_balances
      `;

      const ledgerResult = await pool.query(ledgerSummaryQuery, [validStartDate, validEndDate]);
      const ledgerSummary = ledgerResult.rows[0] || {};

      // Get top debtors for management attention
      const topDebtorsQuery = `
        SELECT 
          u.username,
          b.barangay_name,
          SUM(i.amount) - COALESCE(SUM(p.amount), 0) as balance,
          COUNT(CASE WHEN i.status = 'overdue' THEN 1 END) as overdue_count
        FROM invoices i
        LEFT JOIN payments p ON p.invoice_id = i.invoice_id
        LEFT JOIN users u ON i.user_id = u.user_id
        LEFT JOIN addresses a ON u.address_id = a.address_id
        LEFT JOIN barangays b ON a.barangay_id = b.barangay_id
        WHERE DATE(i.generated_date) BETWEEN $1 AND $2
        GROUP BY u.username, b.barangay_name
        HAVING SUM(i.amount) - COALESCE(SUM(p.amount), 0) > 0
        ORDER BY balance DESC
        LIMIT 10
      `;

      const topDebtorsResult = await pool.query(topDebtorsQuery, [validStartDate, validEndDate]);

      // Barangay breakdown
      const barangayBreakdown = {};
      invoices.forEach(invoice => {
        const barangay = invoice.barangay_name || 'Unknown';
        if (!barangayBreakdown[barangay]) {
          barangayBreakdown[barangay] = { count: 0, totalAmount: 0, paidAmount: 0 };
        }
        barangayBreakdown[barangay].count++;
        barangayBreakdown[barangay].totalAmount += parseFloat(invoice.amount || 0);
        if (invoice.invoice_status === 'paid') {
          barangayBreakdown[barangay].paidAmount += parseFloat(invoice.amount || 0);
        }
      });

      const finalResult = {
        reportType: 'billing-payment',
        summary,
        ledgerAnalytics: {
          userBalances: ledgerSummary,
          topDebtors: topDebtorsResult.rows,
          balanceDistribution: {
            totalUsers: parseInt(ledgerSummary.total_users || 0),
            usersWithBalance: parseInt(ledgerSummary.users_with_balance || 0),
            highBalanceUsers: parseInt(ledgerSummary.high_balance_users || 0),
            averageBalance: parseFloat(ledgerSummary.avg_balance || 0),
            maxBalance: parseFloat(ledgerSummary.max_balance || 0),
            minBalance: parseFloat(ledgerSummary.min_balance || 0)
          }
        },
        invoices: result.rows,
        planBreakdown,
        barangayBreakdown,
        filters: filters,
        dateRange: { startDate: validStartDate, endDate: validEndDate },
        generatedAt: new Date().toISOString()
      };

      console.log('Financial report generated successfully');
      return finalResult;
      
    } catch (error) {
      console.error('=== FINANCIAL REPORT ERROR ===');
      console.error('Error type:', error.constructor.name);
      console.error('Error message:', error.message);
      console.error('Error stack:', error.stack);
      throw error;
    }
  }

  // ðŸš› SPECIAL PICKUPS REPORT GENERATOR (COMPREHENSIVE)
  static async generateSpecialPickupsReport(filters = {}, startDate, endDate) {
    try {
      console.log('Generating Special Pickups Report with filters:', filters);
      
      // FIXED: Enhanced special pickups query with real data and safe joins
      let query = `
        SELECT 
          spr.request_id,
          spr.user_id,
          spr.waste_type,
          spr.description,
          spr.pickup_date,
          spr.pickup_time,
          spr.address as pickup_address,
          spr.notes,
          spr.image_url,
          spr.message,
          spr.status,
          spr.collector_id,
          spr.estimated_price,
          spr.final_price,
          spr.price_status,
          spr.created_at,
          spr.updated_at,
          DATE(spr.created_at) as request_date,
          -- Calculate response time
          CASE 
            WHEN spr.updated_at IS NOT NULL AND spr.created_at IS NOT NULL THEN
              EXTRACT(EPOCH FROM (spr.updated_at - spr.created_at))/3600
            ELSE 0
          END as response_time_hours,
          -- Get user and barangay info (with safe joins)
          COALESCE(u.username, 'Unknown User') as resident_name,
          COALESCE(b.barangay_name, 'Unknown Barangay') as barangay_name,
          COALESCE(b.barangay_id, 0) as barangay_id,
          -- Get collector info (with safe joins)
          COALESCE(u_collector.username, 'Unassigned') as collector_name
        FROM special_pickup_requests spr
        LEFT JOIN users u ON CAST(spr.user_id AS INTEGER) = CAST(u.user_id AS INTEGER)
        LEFT JOIN addresses a ON CAST(u.address_id AS INTEGER) = CAST(a.address_id AS INTEGER)
        LEFT JOIN barangays b ON CAST(a.barangay_id AS INTEGER) = CAST(b.barangay_id AS INTEGER)
        LEFT JOIN collectors c ON CAST(spr.collector_id AS INTEGER) = CAST(c.collector_id AS INTEGER)
        LEFT JOIN users u_collector ON CAST(c.user_id AS INTEGER) = CAST(u_collector.user_id AS INTEGER)
        WHERE 1=1
      `;
      
      const params = [];
      let paramCount = 0;
      
      // Validate dates
      const validStartDate = startDate && !isNaN(Date.parse(startDate)) ? startDate : '1900-01-01';
      const validEndDate = endDate && !isNaN(Date.parse(endDate)) ? endDate : '2100-12-31';

      // Apply comprehensive filters with proper type casting
      if (validStartDate && validEndDate) {
        paramCount += 2;
        query += ` AND DATE(spr.created_at) BETWEEN CAST($${paramCount-1} AS DATE) AND CAST($${paramCount} AS DATE)`;
        params.push(validStartDate, validEndDate);
      }
      
      // Apply barangay filter
      if (filters.barangay && filters.barangay !== '' && filters.barangay !== 'all') {
        console.log('Applying barangay filter to special pickup report:', filters.barangay, 'Type:', typeof filters.barangay);
        const barangayId = parseInt(filters.barangay);
        if (!isNaN(barangayId) && barangayId > 0) {
          paramCount++;
          query += ` AND b.barangay_id = $${paramCount}::integer`;
          params.push(barangayId);
        }
      }
      
      // Apply waste type filter
      if (filters.wasteType && filters.wasteType !== '' && filters.wasteType !== 'all') {
        console.log('Applying waste type filter:', filters.wasteType);
        paramCount++;
        query += ` AND spr.waste_type ILIKE $${paramCount}`;
        params.push(`%${filters.wasteType}%`);
      }
      
      // Apply status filter
      if (filters.status && filters.status !== 'all' && filters.status !== '') {
        console.log('Applying status filter:', filters.status);
        paramCount++;
        query += ` AND spr.status = $${paramCount}`;
        params.push(filters.status);
      }
      
      // Apply price status filter
      if (filters.priceStatus && filters.priceStatus !== '' && filters.priceStatus !== 'all') {
        console.log('Applying price status filter:', filters.priceStatus);
        paramCount++;
        query += ` AND spr.price_status = $${paramCount}`;
        params.push(filters.priceStatus);
      }
      
      // Apply collector filter
      if (filters.collector && filters.collector !== '' && filters.collector !== 'all') {
        console.log('Applying collector filter to special pickup report:', filters.collector, 'Type:', typeof filters.collector);
        const collectorId = parseInt(filters.collector);
        if (!isNaN(collectorId) && collectorId > 0) {
          paramCount++;
          query += ` AND c.collector_id = $${paramCount}::integer`;
          params.push(collectorId);
        }
      }
      
      // Apply amount filters
      if (filters.minAmount && filters.minAmount !== '') {
        const minAmount = parseFloat(filters.minAmount);
        if (!isNaN(minAmount) && minAmount > 0) {
          paramCount++;
          query += ` AND spr.final_price >= $${paramCount}`;
          params.push(minAmount);
        }
      }
      
      if (filters.maxAmount && filters.maxAmount !== '') {
        const maxAmount = parseFloat(filters.maxAmount);
        if (!isNaN(maxAmount) && maxAmount > 0) {
          paramCount++;
          query += ` AND spr.final_price <= $${paramCount}`;
          params.push(maxAmount);
        }
      }
      
      query += ` ORDER BY spr.pickup_date DESC, spr.created_at DESC`;
      
      const result = await pool.query(query, params);
      
      // Get waste type analytics
      const wasteTypeAnalyticsQuery = `
        SELECT 
          waste_type,
          COUNT(*) as request_count,
          AVG(final_price) as avg_price,
          SUM(final_price) as total_revenue,
          COUNT(CASE WHEN status = 'collected' THEN 1 END) as completed_count,
          ROUND(COUNT(CASE WHEN status = 'collected' THEN 1 END) * 100.0 / COUNT(*), 2) as completion_rate
        FROM special_pickup_requests
        WHERE pickup_date BETWEEN $1 AND $2
        GROUP BY waste_type
        ORDER BY request_count DESC
      `;
      
      const wasteTypeAnalyticsResult = await pool.query(wasteTypeAnalyticsQuery, [
        validStartDate, 
        validEndDate
      ]);
      
      // Calculate comprehensive summary
      const pickups = result.rows;
      const summary = {
        totalRequests: pickups.length,
        pending: pickups.filter(r => r.status === 'pending').length,
        inProgress: pickups.filter(r => r.status === 'in_progress').length,
        collected: pickups.filter(r => r.status === 'collected' || r.status === 'completed').length,
        cancelled: pickups.filter(r => r.status === 'cancelled').length,
        completionRate: 0,
        totalRevenue: pickups.reduce((sum, r) => sum + parseFloat(r.final_price || 0), 0),
        avgPrice: 0,
        avgResponseTimeHours: 0,
        avgCompletionDelayDays: 0,
        statusBreakdown: {
          pending: pickups.filter(r => r.status === 'pending').length,
          in_progress: pickups.filter(r => r.status === 'in_progress').length,
          collected: pickups.filter(r => r.status === 'collected').length,
          cancelled: pickups.filter(r => r.status === 'cancelled').length
        },
        priceStatusBreakdown: {
          pending: pickups.filter(r => r.price_status === 'pending').length,
          negotiating: pickups.filter(r => r.price_status === 'negotiating').length,
          agreed: pickups.filter(r => r.price_status === 'agreed').length
        },
        wasteTypeBreakdown: {},
        barangayBreakdown: {},
        collectorPerformance: {},
        monthlyTrends: {}
      };
      
      // Calculate rates and averages
      if (summary.totalRequests > 0) {
        summary.completionRate = ((summary.collected / summary.totalRequests) * 100).toFixed(2);
        
        const pricedPickups = pickups.filter(r => r.final_price > 0);
        if (pricedPickups.length > 0) {
          summary.avgPrice = (summary.totalRevenue / pricedPickups.length).toFixed(2);
        }
        
        const respondedPickups = pickups.filter(r => r.response_time_hours > 0);
        if (respondedPickups.length > 0) {
          summary.avgResponseTimeHours = (respondedPickups.reduce((sum, r) => sum + parseFloat(r.response_time_hours), 0) / respondedPickups.length).toFixed(1);
        }
        
        const completedPickups = pickups.filter(r => r.completion_delay_days !== null);
        if (completedPickups.length > 0) {
          summary.avgCompletionDelayDays = (completedPickups.reduce((sum, r) => sum + parseFloat(r.completion_delay_days || 0), 0) / completedPickups.length).toFixed(1);
        }
      }
      
      // Waste type breakdown
      pickups.forEach(pickup => {
        const wasteType = pickup.waste_type || 'Unknown';
        if (!summary.wasteTypeBreakdown[wasteType]) {
          summary.wasteTypeBreakdown[wasteType] = {
            totalRequests: 0,
            completed: 0,
            totalRevenue: 0,
            avgPrice: 0,
            completionRate: 0
          };
        }
        summary.wasteTypeBreakdown[wasteType].totalRequests++;
        summary.wasteTypeBreakdown[wasteType].totalRevenue += parseFloat(pickup.final_price || 0);
        if (pickup.status === 'collected') {
          summary.wasteTypeBreakdown[wasteType].completed++;
        }
      });
      
      // Calculate completion rates and avg prices for waste types
      Object.keys(summary.wasteTypeBreakdown).forEach(wasteType => {
        const breakdown = summary.wasteTypeBreakdown[wasteType];
        breakdown.completionRate = breakdown.totalRequests > 0 ? 
          ((breakdown.completed / breakdown.totalRequests) * 100).toFixed(2) : 0;
        breakdown.avgPrice = breakdown.completed > 0 ? 
          (breakdown.totalRevenue / breakdown.completed).toFixed(2) : 0;
      });
      
      // Barangay breakdown
      pickups.forEach(pickup => {
        const barangay = pickup.barangay_name || 'Unknown';
        if (!summary.barangayBreakdown[barangay]) {
          summary.barangayBreakdown[barangay] = {
            totalRequests: 0,
            completed: 0,
            totalRevenue: 0,
            completionRate: 0
          };
        }
        summary.barangayBreakdown[barangay].totalRequests++;
        summary.barangayBreakdown[barangay].totalRevenue += parseFloat(pickup.final_price || 0);
        if (pickup.status === 'collected') {
          summary.barangayBreakdown[barangay].completed++;
        }
      });
      
      // Calculate completion rates for barangays
      Object.keys(summary.barangayBreakdown).forEach(barangay => {
        const breakdown = summary.barangayBreakdown[barangay];
        breakdown.completionRate = breakdown.totalRequests > 0 ? 
          ((breakdown.completed / breakdown.totalRequests) * 100).toFixed(2) : 0;
      });
      
      // Collector performance
      pickups.forEach(pickup => {
        if (pickup.collector_username) {
          const collector = pickup.collector_username;
          if (!summary.collectorPerformance[collector]) {
            summary.collectorPerformance[collector] = {
              totalAssigned: 0,
              completed: 0,
              totalRevenue: 0,
              completionRate: 0,
              avgResponseTime: 0
            };
          }
          summary.collectorPerformance[collector].totalAssigned++;
          summary.collectorPerformance[collector].totalRevenue += parseFloat(pickup.final_price || 0);
          if (pickup.status === 'collected') {
            summary.collectorPerformance[collector].completed++;
          }
        }
      });
      
      // Calculate collector performance rates
      Object.keys(summary.collectorPerformance).forEach(collector => {
        const performance = summary.collectorPerformance[collector];
        performance.completionRate = performance.totalAssigned > 0 ? 
          ((performance.completed / performance.totalAssigned) * 100).toFixed(2) : 0;
      });
      
      // Monthly trends
      pickups.forEach(pickup => {
        const month = new Date(pickup.pickup_date).toISOString().slice(0, 7); // YYYY-MM
        if (!summary.monthlyTrends[month]) {
          summary.monthlyTrends[month] = {
            requestsReceived: 0,
            requestsCompleted: 0,
            totalRevenue: 0
          };
        }
        summary.monthlyTrends[month].requestsReceived++;
        summary.monthlyTrends[month].totalRevenue += parseFloat(pickup.final_price || 0);
        if (pickup.status === 'collected') {
          summary.monthlyTrends[month].requestsCompleted++;
        }
      });
      
      return {
        reportType: 'special-pickup',
        summary,
        pickups: result.rows,
        wasteTypeAnalytics: wasteTypeAnalyticsResult.rows,
        filters: filters,
        dateRange: { startDate: validStartDate, endDate: validEndDate },
        generatedAt: new Date().toISOString()
      };
      
    } catch (error) {
      console.error('Error generating special pickups report:', error);
      throw error;
    }
  }

  static async getBarangays(req, res) {
    try {
      const query = `SELECT barangay_id, barangay_name FROM barangays ORDER BY barangay_name`;
      const result = await pool.query(query);
      res.json(result.rows);
    } catch (error) {
      console.error('Error fetching barangays:', error);
      res.status(500).json({ error: 'Failed to fetch barangays', details: error.message });
    }
  }

  static async getCollectors(req, res) {
    try {
      const query = `
        SELECT c.collector_id, u.username
        FROM collectors c
        JOIN users u ON c.user_id = u.user_id
        ORDER BY u.username
      `;
      const result = await pool.query(query);
      res.json(result.rows);
    } catch (error) {
      console.error('Error fetching collectors:', error);
      res.status(500).json({ error: 'Failed to fetch collectors', details: error.message });
    }
  }

  static async getTrucks(req, res) {
    try {
      const query = `SELECT truck_id, truck_number FROM trucks ORDER BY truck_number`;
      const result = await pool.query(query);
      res.json(result.rows);
    } catch (error) {
      console.error('Error fetching trucks:', error);
      res.status(500).json({ error: 'Failed to fetch trucks', details: error.message });
    }
  }

  static async getSubdivisions(req, res) {
    try {
      const query = `SELECT subdivision_id, subdivision_name FROM subdivisions ORDER BY subdivision_name`;
      const result = await pool.query(query);
      res.json(result.rows);
    } catch (error) {
      console.error('Error fetching subdivisions:', error);
      res.status(500).json({ error: 'Failed to fetch subdivisions', details: error.message });
    }
  }

  static async getTeams(req, res) {
    try {
      const query = `
        SELECT DISTINCT 
          ca.assignment_id as team_id, 
          COALESCE(ca.shift_label, 'Team ' || ca.assignment_id) as team_name 
        FROM collector_assignments ca 
        WHERE ca.shift_label IS NOT NULL 
        ORDER BY team_name
      `;
      const result = await pool.query(query);
      res.json(result.rows);
    } catch (error) {
      console.error('Error fetching teams:', error);
      res.status(500).json({ error: 'Failed to fetch teams', details: error.message });
    }
  }

  static async getRoutes(req, res) {
    try {
      const query = `
        SELECT DISTINCT 
          rs.stop_id as route_id, 
          COALESCE(rs.planned_waste_type, 'Route ' || rs.stop_id) as route_name 
        FROM route_stops rs 
        WHERE rs.planned_waste_type IS NOT NULL 
        ORDER BY route_name
      `;
      const result = await pool.query(query);
      res.json(result.rows);
    } catch (error) {
      console.error('Error fetching routes:', error);
      res.status(500).json({ error: 'Failed to fetch routes', details: error.message });
    }
  }

  static async getPlans(req, res) {
    try {
      const query = `SELECT plan_id, plan_name FROM subscription_plans ORDER BY plan_name`;
      const result = await pool.query(query);
      res.json(result.rows);
    } catch (error) {
      console.error('Error fetching plans:', error);
      res.status(500).json({ error: 'Failed to fetch plans', details: error.message });
    }
  }

  static async getWasteTypes(req, res) {
    try {
      const query = `
        SELECT 
          ROW_NUMBER() OVER (ORDER BY waste_type) as waste_type_id,
          waste_type as waste_type_name 
        FROM (
          SELECT DISTINCT waste_type 
          FROM collection_schedules 
          WHERE waste_type IS NOT NULL
          UNION
          SELECT DISTINCT waste_type 
          FROM special_pickup_requests 
        ) wt
        ORDER BY waste_type_name
      `;
      const result = await pool.query(query);
      res.json(result.rows);
    } catch (error) {
      console.error('Error fetching waste types:', error);
      res.status(500).json({ error: 'Failed to fetch waste types', details: error.message });
    }
  }

  // ðŸ“„ GENERATE PDF DIRECTLY FROM REPORT DATA (for preview downloads)
  static async generateDirectPDF(req, res) {
    try {
      const { reportData } = req.body;
      
      if (!reportData) {
        return res.status(400).json({ error: 'Report data is required' });
      }
      
      console.log('Generating direct PDF for report type:', reportData.type);
      
      // Use the same PDF generation logic
      return await ReportController.generatePDF(reportData, res);
      
    } catch (error) {
      console.error('Error generating direct PDF:', error);
      res.status(500).json({ error: 'Failed to generate PDF', details: error.message });
    }
  }

  //  GENERATE PDF REPORT
  static async generatePDF(reportData, res) {
    try {
      const htmlPdf = require('html-pdf-node');
      
      // Generate HTML content for the report
      const htmlContent = ReportController.generateReportHTML(reportData);
      
      const options = {
        format: 'A4',
        border: {
          top: '0.5in',
          right: '0.5in',
          bottom: '0.5in',
          left: '0.5in'
        }
      };

      const file = { content: htmlContent };
      
      // Generate PDF
      const pdfBuffer = await htmlPdf.generatePdf(file, options);
      
      // Set response headers for PDF download
      const filename = `WSBS_Report_${reportData.type}_${reportData.report_id}_${new Date().toISOString().split('T')[0]}.pdf`;
      
      res.setHeader('Content-Type', 'application/pdf');
      res.setHeader('Content-Disposition', `attachment; filename="${filename}"`);
      res.setHeader('Content-Length', pdfBuffer.length);
      
      // Send PDF buffer
      res.send(pdfBuffer);
      
    } catch (error) {
      console.error('Error generating PDF:', error);
      res.status(500).json({ error: 'Failed to generate PDF', details: error.message });
    }
  }

  // ðŸŽ¨ GENERATE HTML TEMPLATE FOR PDF
  static generateReportHTML(reportData) {
    const { type, generated_by, date, period, data = {}, report_id, start_date, end_date } = reportData;

    // Helper functions
    const formatDate = (value) => {
      if (!value) return 'â€”';
      const parsed = new Date(value);
      if (Number.isNaN(parsed.getTime())) return value;
      return parsed.toLocaleDateString('en-US', { month: 'short', day: '2-digit', year: 'numeric' });
    };

    const formatCurrency = (value) => {
      const numeric = Number(value);
      if (Number.isNaN(numeric)) return '';
      return `â‚±${numeric.toLocaleString('en-PH', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}`;
    };

    const numericValue = (value) => {
      const numeric = Number(value);
      return Number.isNaN(numeric) ? 0 : numeric;
    };

    // Format report type for display
    const reportTypeDisplay = {
      'collection-report': 'Collection Report',
      'billing-report': 'Billing Report', 
      'regular-pickup': 'Collection Report',
      'billing-payment': 'Billing Report',
      'special-pickup': 'Special Pickup Report'
    }[type] || 'WSBS Report';

    const dateRangeLabel = (start_date && end_date)
      ? `${formatDate(start_date)} â€“ ${formatDate(end_date)}`
      : (period && period !== 'custom' ? period : formatDate(date));

    // Generate summary cards and ledger rows
    let summaryCardsHTML = '';
    let ledgerRowsHTML = '';
    let totalAmount = 0;

    // Handle different report types
    if (type === 'collection-report' || type === 'regular-pickup') {
      const summary = data.summary || {};
      summaryCardsHTML = `
        <div class="summary-cards">
          <div class="card"><span class="label">Total Collections</span><span class="value">${summary.totalCollections || summary.totalSchedules || 0}</span></div>
          <div class="card"><span class="label">Regular Pickups</span><span class="value">${summary.regularPickups || 0}</span></div>
          <div class="card"><span class="label">Special Pickups</span><span class="value">${summary.specialPickups || 0}</span></div>
          <div class="card"><span class="label">Completion Rate</span><span class="value">${summary.completionRate || 0}%</span></div>
          <div class="card"><span class="label">Missed</span><span class="value">${summary.missedCollections || 0}</span></div>
        </div>
      `;

      const collections = Array.isArray(data.collections) ? data.collections : [];
      if (collections.length === 0) {
        ledgerRowsHTML = '<tr><td colspan="4" class="empty">No collection data available for this period.</td></tr>';
      } else {
        ledgerRowsHTML = collections.map(item => {
          const amountValue = numericValue(item.waste_amount || item.final_price || item.amount);
          totalAmount += amountValue;
          const description = [item.collection_type || 'Regular Pickup', `Status: ${(item.status || '').toUpperCase()}`]
            .concat(item.location ? [`Location: ${item.location}`] : [])
            .concat(item.collector_name ? [`Collector: ${item.collector_name}`] : [])
            .concat(item.special_notes && item.special_notes !== 'N/A' ? [item.special_notes] : [])
            .join(' â€¢ ');
          return `
            <tr>
              <td>${formatDate(item.collection_date || item.created_at)}</td>
              <td>${item.resident_name || item.customer_name || 'Unknown Resident'}</td>
              <td>${description}</td>
              <td class="right">${amountValue ? formatCurrency(amountValue) : ''}</td>
            </tr>
          `;
        }).join('');
      }

    } else if (type === 'billing-report' || type === 'billing-payment') {
      const summary = data.summary || {};
      summaryCardsHTML = `
        <div class="summary-cards">
          <div class="card"><span class="label">Total Invoices</span><span class="value">${summary.totalInvoices || 0}</span></div>
          <div class="card"><span class="label">Paid Invoices</span><span class="value">${summary.paidInvoices || 0}</span></div>
          <div class="card"><span class="label">Unpaid Invoices</span><span class="value">${summary.unpaidInvoices || 0}</span></div>
          <div class="card"><span class="label">Collection Rate</span><span class="value">${summary.collectionRate || 0}%</span></div>
          <div class="card"><span class="label">Total Amount</span><span class="value">${formatCurrency(summary.totalAmount || 0)}</span></div>
        </div>
      `;

      const invoices = Array.isArray(data.invoices) ? data.invoices : [];
      if (invoices.length === 0) {
        ledgerRowsHTML = '<tr><td colspan="4" class="empty">No billing data available for this period.</td></tr>';
      } else {
        ledgerRowsHTML = invoices.map(invoice => {
          const amountValue = numericValue(invoice.amount);
          totalAmount += amountValue;
          const description = `${invoice.plan_name || 'Subscription'} â€¢ Status: ${(invoice.invoice_status || '').toUpperCase()}${invoice.notes ? ' â€¢ ' + invoice.notes : ''}`;
          return `
            <tr>
              <td>${formatDate(invoice.generated_date)}</td>
              <td>${invoice.username || invoice.resident_name || 'Unknown User'}</td>
              <td>${description}</td>
              <td class="right">${formatCurrency(amountValue)}</td>
            </tr>
          `;
        }).join('');
      }
    } else {
      // Fallback for other report types
      const summary = data.summary || {};
      summaryCardsHTML = Object.entries(summary).slice(0, 5).map(([key, value]) => `
        <div class="card"><span class="label">${key}</span><span class="value">${value}</span></div>
      `).join('');
      ledgerRowsHTML = '<tr><td colspan="4" class="empty">Detailed data unavailable for this report type.</td></tr>';
    }

    const totalRow = totalAmount > 0 ? `
      <tr class="total-row">
        <td colspan="3" class="right"><strong>TOTAL AMOUNT</strong></td>
        <td class="right"><strong>${formatCurrency(totalAmount)}</strong></td>
      </tr>
    ` : '';

    return `
      <!DOCTYPE html>
      <html>
      <head>
        <meta charset="UTF-8">
        <title>WSBS ${reportTypeDisplay}</title>
        <style>
          * { box-sizing: border-box; }
          body { font-family: Arial, sans-serif; margin: 0; padding: 20px; line-height: 1.4; color: #333; }
          
          .header { display: flex; align-items: center; justify-content: space-between; border: 2px solid #000; padding: 15px; margin-bottom: 20px; }
          .logo-section { display: flex; align-items: center; }
          .logo { width: 60px; height: 60px; border: 2px solid #000; display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: 14px; margin-right: 15px; ${wsbsLogoBase64 ? `background-image: url(data:image/png;base64,${wsbsLogoBase64}); background-size: contain; background-repeat: no-repeat; background-position: center;` : ''} }
          .company-info h1 { margin: 0; font-size: 18px; font-weight: bold; }
          .company-info p { margin: 2px 0; font-size: 12px; }
          .date-info { text-align: right; font-size: 12px; }
          .date-info p { margin: 2px 0; }
          
          .summary-cards { display: flex; flex-wrap: wrap; gap: 10px; margin: 20px 0; }
          .summary-cards .card { flex: 1; min-width: 120px; border: 1px solid #ddd; padding: 10px; text-align: center; }
          .summary-cards .label { display: block; font-size: 10px; color: #666; margin-bottom: 5px; }
          .summary-cards .value { display: block; font-size: 16px; font-weight: bold; color: #4CAF50; }
          
          .ledger-table { width: 100%; border-collapse: collapse; margin-top: 20px; }
          .ledger-table th { background: #f5f5f5; border: 1px solid #000; padding: 8px; text-align: left; font-weight: bold; font-size: 12px; }
          .ledger-table td { border: 1px solid #000; padding: 8px; font-size: 11px; vertical-align: top; }
          .ledger-table .right { text-align: right; }
          .ledger-table .empty { text-align: center; font-style: italic; color: #666; }
          .ledger-table .total-row { background: #f0f0f0; font-weight: bold; }
          
          .footer { margin-top: 30px; text-align: center; font-size: 10px; color: #666; border-top: 1px solid #ddd; padding-top: 15px; }
        </style>
      </head>
      <body>
        <div class="header">
          <div class="logo-section">
            <div class="logo">${wsbsLogoBase64 ? '' : 'LOGO'}</div>
            <div class="company-info">
              <h1>WSBS - ${reportTypeDisplay}</h1>
              <p>Waste Scheduling and Billing System</p>
            </div>
          </div>
          <div class="date-info">
            <p><strong>As of from â€“ to [Date]</strong></p>
            <p>${dateRangeLabel}</p>
          </div>
        </div>
        
        ${summaryCardsHTML}
        
        <table class="ledger-table">
          <thead>
            <tr>
              <th>DATE</th>
              <th>WHO?</th>
              <th>DESCRIPTION</th>
              <th>AMOUNT</th>
            </tr>
          </thead>
          <tbody>
            ${ledgerRowsHTML}
            ${totalRow}
          </tbody>
        </table>
        
        <div class="footer">
          <p>Generated by WSBS (Waste Scheduling and Billing System) on ${new Date().toLocaleString()}</p>
          <p>Â© 2024 WSBS. All rights reserved. | Report ID: #${report_id}</p>
        </div>
      </body>
      </html>
    `;
  }

  // ðŸ”„ UNIFIED COLLECTION REPORT (Regular + Special Pickups)
  static async generateUnifiedCollectionReport(filters = {}, startDate, endDate) {
    try {
      console.log('=== GENERATING UNIFIED COLLECTION REPORT ===');
      console.log('Filters:', JSON.stringify(filters, null, 2));
      console.log('Date range:', startDate, 'to', endDate);

      // Get regular pickups from collection_stop_events
      let regularQuery = `
        SELECT 
          cse.created_at as collection_date,
          'Regular Pickup' as collection_type,
          cse.action as status,
          COALESCE(u.username, 'Unknown User') as resident_name,
          COALESCE(b.barangay_name, 'Unknown Barangay') as location,
          COALESCE(uc.username, 'Unknown Collector') as collector_name,
          COALESCE(cse.amount::text, '0') as waste_amount,
          'N/A' as special_notes
        FROM collection_stop_events cse
        LEFT JOIN users u ON CAST(cse.user_id AS INTEGER) = CAST(u.user_id AS INTEGER)
        LEFT JOIN addresses a ON u.address_id = a.address_id
        LEFT JOIN barangays b ON CAST(a.barangay_id AS INTEGER) = CAST(b.barangay_id AS INTEGER)
        LEFT JOIN users uc ON CAST(cse.collector_id AS INTEGER) = CAST(uc.user_id AS INTEGER)
        WHERE 1=1
      `;

      // Get special pickups from special_pickup_requests
      let specialQuery = `
        SELECT 
          spr.created_at as collection_date,
          'Special Pickup' as collection_type,
          spr.status,
          COALESCE(u.username, 'Unknown User') as resident_name,
          COALESCE(b.barangay_name, 'Unknown Barangay') as location,
          COALESCE(uc.username, 'Unknown Collector') as collector_name,
          COALESCE(spr.final_price::text, '0') as waste_amount,
          COALESCE(spr.waste_type, 'Mixed Waste') as special_notes
        FROM special_pickup_requests spr
        LEFT JOIN users u ON CAST(spr.user_id AS INTEGER) = CAST(u.user_id AS INTEGER)
        LEFT JOIN addresses a ON u.address_id = a.address_id
        LEFT JOIN barangays b ON CAST(a.barangay_id AS INTEGER) = CAST(b.barangay_id AS INTEGER)
        LEFT JOIN users uc ON CAST(spr.collector_id AS INTEGER) = CAST(uc.user_id AS INTEGER)
        WHERE 1=1
      `;

      const params = [];
      let paramCount = 0;

      // Apply date filters to both queries
      if (startDate && endDate) {
        paramCount += 2;
        const regularDateFilter = ` AND DATE(cse.created_at) BETWEEN CAST($${paramCount-1} AS DATE) AND CAST($${paramCount} AS DATE)`;
        const specialDateFilter = ` AND DATE(spr.created_at) BETWEEN CAST($${paramCount-1} AS DATE) AND CAST($${paramCount} AS DATE)`;
        regularQuery += regularDateFilter;
        specialQuery += specialDateFilter;
        params.push(startDate, endDate);
      }

      // Apply barangay filter
      if (filters.barangay && filters.barangay !== '' && filters.barangay !== 'All Barangays') {
        if (!isNaN(parseInt(filters.barangay))) {
          paramCount++;
          const barangayFilter = ` AND b.barangay_id = $${paramCount}::integer`;
          regularQuery += barangayFilter;
          specialQuery += barangayFilter;
          params.push(parseInt(filters.barangay));
        }
      }

      // Apply status filter with mapping
      if (filters.status && filters.status !== '') {
        let dbStatus = filters.status;
        // Map frontend status to database status
        switch (filters.status) {
          case 'completed':
            dbStatus = 'collected';
            break;
          case 'missed':
            dbStatus = 'missed';
            break;
          case 'pending':
            dbStatus = 'pending';
            break;
        }
        
        paramCount++;
        const statusFilter = ` AND status = $${paramCount}`;
        regularQuery += statusFilter.replace('status', 'cse.action');
        specialQuery += statusFilter.replace('status', 'spr.status');
        params.push(dbStatus);
      }

      // Combine both queries with UNION
      const combinedQuery = `
        (${regularQuery})
        UNION ALL
        (${specialQuery})
        ORDER BY collection_date DESC
      `;

      console.log('Executing unified collection query:', combinedQuery);
      console.log('Query parameters:', params);

      const result = await pool.query(combinedQuery, params);

      // Calculate summary statistics
      const totalCollections = result.rows.length;
      const regularPickups = result.rows.filter(row => row.collection_type === 'Regular Pickup').length;
      const specialPickups = result.rows.filter(row => row.collection_type === 'Special Pickup').length;
      const completedCollections = result.rows.filter(row => 
        row.status === 'collected' || row.status === 'completed'
      ).length;
      const missedCollections = result.rows.filter(row => row.status === 'missed').length;
      const pendingCollections = result.rows.filter(row => 
        row.status === 'pending' || row.status === 'in_progress'
      ).length;

      // Calculate completion rate
      const completionRate = totalCollections > 0 ? 
        ((completedCollections / totalCollections) * 100).toFixed(1) : 0;

      // Group by location
      const locationBreakdown = {};
      result.rows.forEach(row => {
        const location = row.location || 'Unknown Location';
        if (!locationBreakdown[location]) {
          locationBreakdown[location] = {
            total: 0,
            completed: 0,
            regular: 0,
            special: 0
          };
        }
        locationBreakdown[location].total++;
        if (row.status === 'collected' || row.status === 'completed') {
          locationBreakdown[location].completed++;
        }
        if (row.collection_type === 'Regular Pickup') {
          locationBreakdown[location].regular++;
        } else {
          locationBreakdown[location].special++;
        }
      });

      // Group by collector
      const collectorPerformance = {};
      result.rows.forEach(row => {
        const collector = row.collector_name || 'Unknown Collector';
        if (!collectorPerformance[collector]) {
          collectorPerformance[collector] = {
            total: 0,
            completed: 0,
            regular: 0,
            special: 0
          };
        }
        collectorPerformance[collector].total++;
        if (row.status === 'collected' || row.status === 'completed') {
          collectorPerformance[collector].completed++;
        }
        if (row.collection_type === 'Regular Pickup') {
          collectorPerformance[collector].regular++;
        } else {
          collectorPerformance[collector].special++;
        }
      });

      const summary = {
        totalCollections,
        regularPickups,
        specialPickups,
        completedCollections,
        missedCollections,
        pendingCollections,
        completionRate: parseFloat(completionRate),
        regularPercentage: totalCollections > 0 ? ((regularPickups / totalCollections) * 100).toFixed(1) : 0,
        specialPercentage: totalCollections > 0 ? ((specialPickups / totalCollections) * 100).toFixed(1) : 0
      };

      console.log('Collection report summary:', summary);

      return {
        type: 'collection-report',
        period: `${startDate || 'all'} to ${endDate || 'all'}`,
        summary,
        locationBreakdown,
        collectorPerformance,
        collections: result.rows,
        generatedAt: new Date().toISOString()
      };

    } catch (error) {
      console.error('Error generating unified collection report:', error);
      throw error;
    }
  }
}

module.exports = ReportController;
