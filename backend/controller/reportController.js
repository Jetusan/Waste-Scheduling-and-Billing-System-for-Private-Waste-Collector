const { pool } = require('../config/db');

class ReportController {
  // ðŸ“‹ GET ALL REPORTS
  static async getAllReports(req, res) {
    try {
      const query = `
        SELECT * FROM reports 
        ORDER BY created_at DESC
      `;
      const result = await pool.query(query);
      res.json(result.rows);
    } catch (error) {
      console.error('Error fetching reports:', error);
      res.status(500).json({ error: 'Failed to fetch reports', details: error.message });
    }
  }

  // ðŸ—‘ï¸ DELETE REPORT
  static async deleteReport(req, res) {
    try {
      const { id } = req.params;
      const query = `DELETE FROM reports WHERE report_id = $1`;
      await pool.query(query, [id]);
      res.json({ message: 'Report deleted successfully' });
    } catch (error) {
      console.error('Error deleting report:', error);
      res.status(500).json({ error: 'Failed to delete report', details: error.message });
    }
  }

  // ðŸ“¥ DOWNLOAD REPORT (Fixed with PDF Export)
  static async downloadReport(req, res) {
    try {
      const { id } = req.params;
      const { format = 'json' } = req.query; // Support format parameter
      
      const query = `SELECT * FROM reports WHERE report_id = $1`;
      const result = await pool.query(query, [id]);
      
      if (result.rows.length === 0) {
        return res.status(404).json({ error: 'Report not found' });
      }
      
      const report = result.rows[0];
      
      // Fix JSON parsing issue
      let reportData;
      try {
        // Handle both string and object data types
        if (typeof report.data === 'string') {
          reportData = JSON.parse(report.data);
        } else if (typeof report.data === 'object' && report.data !== null) {
          reportData = report.data;
        } else {
          reportData = {};
        }
      } catch (parseError) {
        console.error('JSON parse error:', parseError);
        reportData = {};
      }

      const reportResponse = {
        type: report.type,
        generated_by: report.generated_by,
        date: report.date,
        period: report.period,
        data: reportData,
        report_id: report.report_id,
        start_date: report.start_date,
        end_date: report.end_date,
        status: report.status
      };

      // If PDF format is requested, generate PDF
      if (format === 'pdf') {
        return await ReportController.generatePDF(reportResponse, res);
      }

      // Default: return JSON
      res.json(reportResponse);
      
    } catch (error) {
      console.error('Error downloading report:', error);
      res.status(500).json({ error: 'Failed to download report', details: error.message });
    }
  }

  // ðŸ”„ GENERATE REPORT
  static async generateReport(req, res) {
    try {
      const { type, period, generated_by, start_date, end_date, filters = {} } = req.body;

      console.log('=== REPORT GENERATION REQUEST ===');
      console.log('Type:', type);
      console.log('Generated by:', generated_by);
      console.log('Start date:', start_date);
      console.log('End date:', end_date);
      console.log('Filters:', JSON.stringify(filters, null, 2));

      // Validate required fields
      if (!type) {
        return res.status(400).json({ error: 'Report type is required' });
      }
      if (!period) {
        return res.status(400).json({ error: 'Period is required' });
      }
      if (!generated_by) {
        return res.status(400).json({ error: 'Generated by field is required' });
      }

      let reportData = {};
      let reportType = type;

      // Generate different types of reports based on your database schema
      switch (type) {
        case 'waste-collection':
        case 'regular-pickup':
          console.log('Generating waste collection report...');
          reportData = await ReportController.generateWasteCollectionReport(filters, start_date, end_date);
          reportType = 'regular-pickup';
          break;
        case 'financial-summary':
        case 'billing-payment':
          console.log('Generating financial report...');
          reportData = await ReportController.generateFinancialReport(filters, start_date, end_date);
          reportType = 'billing-payment';
          break;
        case 'special-pickups':
        case 'special-pickup':
          console.log('Generating special pickups report...');
          reportData = await ReportController.generateSpecialPickupsReport(filters, start_date, end_date);
          reportType = 'special-pickup';
          break;
        default:
          console.log('Unknown report type, defaulting to waste collection...');
          reportData = await ReportController.generateWasteCollectionReport(filters, start_date, end_date);
          reportType = 'regular-pickup';
      }

      console.log('Report generation successful, storing in database...');

      // Store the report in the database
      const insertQuery = `
        INSERT INTO reports (type, period, generated_by, date, status, data, start_date, end_date)
        VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
        RETURNING *
      `;

      const reportResult = await pool.query(insertQuery, [
        reportType,
        period,
        generated_by,
        new Date().toISOString().split('T')[0],
        'Completed',
        JSON.stringify(reportData),
        start_date,
        end_date
      ]);

      console.log('Report stored successfully:', reportResult.rows[0].report_id);

      res.json({
        message: 'Report generated successfully',
        report: reportResult.rows[0],
        status: 'Completed'
      });

    } catch (error) {
      console.error('=== REPORT GENERATION ERROR ===');
      console.error('Error type:', error.constructor.name);
      console.error('Error message:', error.message);
      console.error('Error stack:', error.stack);
      console.error('Error details:', error);

      res.status(500).json({
        error: 'Failed to generate report',
        details: error.message,
        type: error.constructor.name,
        stack: error.stack
      });
    }
  }

  // ðŸ’° BILLING REPORTS
  static async generateBillingReport(req, res) {
    try {
      const { startDate, endDate, planType, status, barangay } = req.query;
      
      let query = `
        SELECT 
          DATE_TRUNC('month', i.generated_date) as billing_month,
          sp.plan_name,
          sp.price,
          b.barangay_name,
          COUNT(i.invoice_id) as total_invoices,
          SUM(i.amount) as total_billed,
          SUM(CASE WHEN i.status = 'paid' THEN i.amount ELSE 0 END) as total_collected,
          SUM(CASE WHEN i.status = 'unpaid' THEN i.amount ELSE 0 END) as outstanding,
          SUM(CASE WHEN i.status = 'overdue' THEN i.amount ELSE 0 END) as overdue_amount,
          ROUND((SUM(CASE WHEN i.status = 'paid' THEN i.amount ELSE 0 END) * 100.0 / 
                 NULLIF(SUM(i.amount), 0)), 2) as collection_rate,
          COUNT(CASE WHEN i.status = 'paid' THEN 1 END) as paid_count,
          COUNT(CASE WHEN i.status = 'unpaid' THEN 1 END) as unpaid_count,
          COUNT(CASE WHEN i.status = 'overdue' THEN 1 END) as overdue_count
        FROM invoices i
        JOIN customer_subscriptions cs ON i.subscription_id = cs.subscription_id
        JOIN subscription_plans sp ON cs.plan_id = sp.plan_id
        JOIN users u ON cs.user_id = u.user_id
        LEFT JOIN addresses a ON u.address_id = a.address_id
        LEFT JOIN barangays b ON a.barangay_id = b.barangay_id
        WHERE 1=1
      `;
      
      const params = [];
      let paramCount = 0;
      
      if (startDate && endDate) {
        paramCount += 2;
        query += ` AND i.generated_date BETWEEN $${paramCount-1} AND $${paramCount}`;
        params.push(startDate, endDate);
      }
      
      if (planType) {
        paramCount++;
        query += ` AND sp.plan_id = $${paramCount}::integer`;
        params.push(planType);
      }
      
      if (status && status !== 'all') {
        paramCount++;
        query += ` AND i.status = $${paramCount}`;
        params.push(status);
      }
      
      if (barangay) {
        paramCount++;
        query += ` AND b.barangay_id = $${paramCount}::integer`;
        params.push(barangay);
      }
      
      query += `
        GROUP BY DATE_TRUNC('month', i.generated_date), sp.plan_name, sp.price, b.barangay_name
        ORDER BY billing_month DESC, total_billed DESC
      `;
      
      const result = await pool.query(query, params);
      
      // Calculate financial summary
      const financialSummary = {
        totalBilled: result.rows.reduce((sum, row) => sum + parseFloat(row.total_billed || 0), 0),
        totalCollected: result.rows.reduce((sum, row) => sum + parseFloat(row.total_collected || 0), 0),
        totalOutstanding: result.rows.reduce((sum, row) => sum + parseFloat(row.outstanding || 0), 0),
        totalOverdue: result.rows.reduce((sum, row) => sum + parseFloat(row.overdue_amount || 0), 0),
        overallCollectionRate: 0,
        invoiceStats: {
          total: result.rows.reduce((sum, row) => sum + parseInt(row.total_invoices || 0), 0),
          paid: result.rows.reduce((sum, row) => sum + parseInt(row.paid_count || 0), 0),
          unpaid: result.rows.reduce((sum, row) => sum + parseInt(row.unpaid_count || 0), 0),
          overdue: result.rows.reduce((sum, row) => sum + parseInt(row.overdue_count || 0), 0)
        },
        topPerformingPlans: {},
        worstPerformingBarangays: {}
      };
      
      // Calculate overall collection rate
      if (financialSummary.totalBilled > 0) {
        financialSummary.overallCollectionRate = 
          ((financialSummary.totalCollected / financialSummary.totalBilled) * 100).toFixed(2);
      }
      
      // Group performance by plan and barangay
      result.rows.forEach(row => {
        // By plan
        if (!financialSummary.topPerformingPlans[row.plan_name]) {
          financialSummary.topPerformingPlans[row.plan_name] = {
            totalBilled: 0,
            collectionRate: 0,
            invoiceCount: 0
          };
        }
        financialSummary.topPerformingPlans[row.plan_name].totalBilled += parseFloat(row.total_billed || 0);
        financialSummary.topPerformingPlans[row.plan_name].invoiceCount += parseInt(row.total_invoices || 0);
        
        // By barangay (for worst performers - high outstanding)
        if (row.barangay_name && parseFloat(row.outstanding || 0) > 0) {
          if (!financialSummary.worstPerformingBarangays[row.barangay_name]) {
            financialSummary.worstPerformingBarangays[row.barangay_name] = 0;
          }
          financialSummary.worstPerformingBarangays[row.barangay_name] += parseFloat(row.outstanding || 0);
        }
      });
      
      res.json({
        type: 'billing-report',
        period: `${startDate || 'all'} to ${endDate || 'all'}`,
        financialSummary,
        monthlyBreakdown: result.rows,
        generatedAt: new Date().toISOString()
      });
      
    } catch (error) {
      console.error('Error generating billing report:', error);
      res.status(500).json({ error: 'Failed to generate billing report', details: error.message });
    }
  }

  // ðŸ“‹ COMBINED DASHBOARD REPORT
  static async generateDashboardReport(req, res) {
    try {
      const { period = '30' } = req.query; // Last 30 days by default
      
      const endDate = new Date();
      const startDate = new Date();
      startDate.setDate(startDate.getDate() - parseInt(period));
      
      // Get collection performance
      const collectionQuery = `
        SELECT 
          COUNT(*) as total_schedules,
          COUNT(CASE WHEN cr.status = 'completed' THEN 1 END) as completed,
          COUNT(CASE WHEN cr.status = 'missed' THEN 1 END) as missed,
          COUNT(CASE WHEN cr.status = 'partial' THEN 1 END) as partial
        FROM collection_schedules cs
        LEFT JOIN collection_results cr ON cs.schedule_id = cr.schedule_id
        WHERE cs.created_at BETWEEN $1 AND $2
      `;
      
      // Get billing performance
      const billingQuery = `
        SELECT 
          COUNT(*) as total_invoices,
          SUM(amount) as total_amount,
          SUM(CASE WHEN status = 'paid' THEN amount ELSE 0 END) as paid_amount,
          COUNT(CASE WHEN status = 'paid' THEN 1 END) as paid_count
        FROM invoices
        WHERE generated_date BETWEEN $1 AND $2
      `;
      
      // Get user activity
      const userQuery = `
        SELECT 
          r.role_name,
          COUNT(u.user_id) as user_count
        FROM users u
        JOIN roles r ON u.role_id = r.role_id
        WHERE u.created_at BETWEEN $1 AND $2 OR u.updated_at BETWEEN $1 AND $2
        GROUP BY r.role_name
      `;
      
      const [collectionResult, billingResult, userResult] = await Promise.all([
        pool.query(collectionQuery, [startDate, endDate]),
        pool.query(billingQuery, [startDate, endDate]),
        pool.query(userQuery, [startDate, endDate])
      ]);
      
      const dashboard = {
        period: `Last ${period} days`,
        collection: collectionResult.rows[0] || {},
        billing: billingResult.rows[0] || {},
        users: userResult.rows,
        generatedAt: new Date().toISOString()
      };
      
      // Calculate rates
      if (dashboard.collection.total_schedules > 0) {
        dashboard.collection.completion_rate = 
          ((dashboard.collection.completed / dashboard.collection.total_schedules) * 100).toFixed(2);
      }
      
      if (dashboard.billing.total_amount > 0) {
        dashboard.billing.collection_rate = 
          ((dashboard.billing.paid_amount / dashboard.billing.total_amount) * 100).toFixed(2);
      }
      
      res.json({
        type: 'dashboard-report',
        dashboard,
        generatedAt: new Date().toISOString()
      });
      
    } catch (error) {
      console.error('Error generating dashboard report:', error);
      res.status(500).json({ error: 'Failed to generate dashboard report', details: error.message });
    }
  }

  // ðŸŽ¯ PERFORMANCE INSIGHTS
  static async generateInsightsReport(req, res) {
    try {
      // Get top performing barangays
      const topBarangaysQuery = `
        SELECT 
          b.barangay_name,
          COUNT(DISTINCT cs.subscription_id) as active_subscriptions,
          COUNT(CASE WHEN i.status = 'paid' THEN 1 END) as paid_invoices,
          COUNT(i.invoice_id) as total_invoices,
          ROUND((COUNT(CASE WHEN i.status = 'paid' THEN 1 END) * 100.0 / 
                 NULLIF(COUNT(i.invoice_id), 0)), 2) as payment_rate
        FROM barangays b
        LEFT JOIN addresses a ON b.barangay_id = a.barangay_id
        LEFT JOIN users u ON a.address_id = u.address_id
        LEFT JOIN customer_subscriptions cs ON u.user_id = cs.user_id
        LEFT JOIN invoices i ON cs.subscription_id = i.subscription_id
        GROUP BY b.barangay_id, b.barangay_name
        HAVING COUNT(i.invoice_id) > 0
        ORDER BY payment_rate DESC, active_subscriptions DESC
        LIMIT 10
      `;
      
      // Get collection efficiency by collector
      const collectorEfficiencyQuery = `
        SELECT 
          u.username as collector_name,
          COUNT(cr.result_id) as total_assignments,
          COUNT(CASE WHEN cr.status = 'completed' THEN 1 END) as completed_collections,
          ROUND((COUNT(CASE WHEN cr.status = 'completed' THEN 1 END) * 100.0 / 
                 NULLIF(COUNT(cr.result_id), 0)), 2) as efficiency_rate
        FROM collectors c
        JOIN users u ON c.user_id = u.user_id
        LEFT JOIN collection_results cr ON c.collector_id = cr.collector_id
        WHERE c.status = 'active'
        GROUP BY c.collector_id, u.username
        ORDER BY efficiency_rate DESC, completed_collections DESC
      `;
      
      const [topBarangays, collectorEfficiency] = await Promise.all([
        pool.query(topBarangaysQuery),
        pool.query(collectorEfficiencyQuery)
      ]);
      
      res.json({
        type: 'insights-report',
        insights: {
          topPerformingBarangays: topBarangays.rows,
          collectorEfficiency: collectorEfficiency.rows,
          recommendations: [
            {
              category: 'Collection',
              suggestion: 'Focus on training collectors with efficiency rates below 80%',
              priority: 'High'
            },
            {
              category: 'Billing',
              suggestion: 'Implement targeted collection campaigns in underperforming barangays',
              priority: 'Medium'
            },
            {
              category: 'Operations',
              suggestion: 'Consider increasing frequency in high-performing areas',
              priority: 'Low'
            }
          ]
        },
        generatedAt: new Date().toISOString()
      });
      
    } catch (error) {
      console.error('Error generating insights report:', error);
      res.status(500).json({ error: 'Failed to generate insights report', details: error.message });
    }
  }

  // ðŸ“… REGULAR PICKUP REPORT GENERATOR (FIXED - Uses Real Collection Data)
  static async generateWasteCollectionReport(filters = {}, startDate, endDate) {
    try {
      console.log('=== WASTE COLLECTION REPORT ===');
      console.log('Filters:', filters);
      console.log('Start date:', startDate);
      console.log('End date:', endDate);

      // Validate dates
      const validStartDate = startDate && !isNaN(Date.parse(startDate)) ? startDate : '1900-01-01';
      const validEndDate = endDate && !isNaN(Date.parse(endDate)) ? endDate : '2100-12-31';

      // FIXED: Query actual collection data from collection_stop_events
      // Start with a simple query to avoid JOIN type issues
      let query = `
        SELECT
          cse.id,
          cse.action as status,
          cse.stop_id,
          cse.schedule_id,
          cse.user_id,
          cse.collector_id,
          cse.notes,
          cse.amount,
          cse.created_at,
          DATE(cse.created_at) as collection_date,
          -- Get user and barangay info (with safe joins)
          COALESCE(u.username, 'Unknown User') as resident_name,
          COALESCE(b.barangay_name, 'Unknown Barangay') as barangay_name,
          COALESCE(b.barangay_id, 0) as barangay_id,
          -- Get collector info (with safe joins)
          COALESCE(uc.username, 'Unknown Collector') as collector_name,
          -- Get schedule info if available (with safe joins)
          COALESCE(cs.waste_type, 'Mixed Waste') as waste_type,
          COALESCE(cs.schedule_date, 
            CASE EXTRACT(DOW FROM cse.created_at)
              WHEN 0 THEN 'Sunday'
              WHEN 1 THEN 'Monday' 
              WHEN 2 THEN 'Tuesday'
              WHEN 3 THEN 'Wednesday'
              WHEN 4 THEN 'Thursday'
              WHEN 5 THEN 'Friday'
              WHEN 6 THEN 'Saturday'
            END
          ) as schedule_date,
          COALESCE(cs.time_range, 
            CASE 
              WHEN EXTRACT(HOUR FROM cse.created_at) BETWEEN 6 AND 11 THEN '06:00-12:00'
              WHEN EXTRACT(HOUR FROM cse.created_at) BETWEEN 12 AND 17 THEN '12:00-18:00'
              ELSE '18:00-06:00'
            END
          ) as time_range
        FROM collection_stop_events cse
        LEFT JOIN users u ON CAST(cse.user_id AS INTEGER) = CAST(u.user_id AS INTEGER)
        LEFT JOIN addresses a ON CAST(u.address_id AS INTEGER) = CAST(a.address_id AS INTEGER)
        LEFT JOIN barangays b ON CAST(a.barangay_id AS INTEGER) = CAST(b.barangay_id AS INTEGER)
        LEFT JOIN collectors c ON CAST(cse.collector_id AS INTEGER) = CAST(c.collector_id AS INTEGER)
        LEFT JOIN users uc ON CAST(c.user_id AS INTEGER) = CAST(uc.user_id AS INTEGER)
        LEFT JOIN collection_schedules cs ON CAST(cse.schedule_id AS TEXT) = CAST(cs.schedule_id AS TEXT)
        WHERE 1=1
      `;

      const params = [];
      let paramCount = 0;

      // Apply date filter using actual collection dates
      if (validStartDate && validEndDate) {
        paramCount += 2;
        query += ` AND DATE(cse.created_at) BETWEEN CAST($${paramCount-1} AS DATE) AND CAST($${paramCount} AS DATE)`;
        params.push(validStartDate, validEndDate);
      }

      // Apply barangay filter
      if (filters.barangay && filters.barangay !== '' && filters.barangay !== 'all') {
        console.log('Applying barangay filter:', filters.barangay, 'Type:', typeof filters.barangay);
        // Validate that it's a valid integer
        if (!isNaN(parseInt(filters.barangay))) {
          paramCount++;
          query += ` AND b.barangay_id = CAST($${paramCount} AS INTEGER)`;
          params.push(parseInt(filters.barangay));
        }
      }

      // Apply status filter
      if (filters.status && filters.status !== 'all' && filters.status !== '') {
        console.log('Applying status filter:', filters.status);
        
        // Map frontend status values to database action values
        let dbAction = filters.status;
        switch (filters.status) {
          case 'completed':
          case 'today_completed':
          case 'ontime':
            dbAction = 'collected';
            break;
          case 'missed':
            dbAction = 'missed';
            break;
          case 'pending':
          case 'in_progress':
            dbAction = 'pending';
            break;
          case 'cancelled':
            dbAction = 'cancelled';
            break;
          case 'late':
            // For late collections, we still want collected items but with additional time filtering
            dbAction = 'collected';
            break;
          default:
            dbAction = filters.status;
        }
        
        paramCount++;
        query += ` AND cse.action = $${paramCount}`;
        params.push(dbAction);
      }

      // Apply collector filter
      if (filters.collector && filters.collector !== '' && filters.collector !== 'all') {
        console.log('Applying collector filter:', filters.collector, 'Type:', typeof filters.collector);
        // Validate that it's a valid integer
        if (!isNaN(parseInt(filters.collector))) {
          paramCount++;
          query += ` AND c.collector_id = CAST($${paramCount} AS INTEGER)`;
          params.push(parseInt(filters.collector));
        }
      }

      // Apply waste type filter
      if (filters.wasteType && filters.wasteType !== '' && filters.wasteType !== 'all') {
        console.log('Applying waste type filter:', filters.wasteType);
        paramCount++;
        query += ` AND cs.waste_type ILIKE $${paramCount}`;
        params.push(`%${filters.wasteType}%`);
      }

      query += ` ORDER BY cse.created_at DESC`;

      console.log('Executing query:', query);
      console.log('Query params:', params);

      const result = await pool.query(query, params);
      console.log('Query result rows:', result.rows.length);

      // Analytics query for waste types and collection performance
      const analyticsQuery = `
        SELECT
          COALESCE(cs.waste_type, 'Mixed Waste') as waste_type,
          COUNT(*) as total_collections,
          COUNT(CASE WHEN cse.action = 'collected' THEN 1 END) as completed_count,
          COUNT(CASE WHEN cse.action = 'missed' THEN 1 END) as missed_count,
          ROUND(COUNT(CASE WHEN cse.action = 'collected' THEN 1 END) * 100.0 / COUNT(*), 2) as completion_rate
        FROM collection_stop_events cse
        LEFT JOIN collection_schedules cs ON CAST(cse.schedule_id AS TEXT) = CAST(cs.schedule_id AS TEXT)
        WHERE DATE(cse.created_at) BETWEEN CAST($1 AS DATE) AND CAST($2 AS DATE)
        GROUP BY cs.waste_type
        ORDER BY total_collections DESC
      `;

      const analyticsResult = await pool.query(analyticsQuery, [validStartDate, validEndDate]);
      console.log('Analytics result:', analyticsResult.rows);

      // Calculate summary based on real collection data
      const summary = {
        totalSchedules: result.rows.length, // Changed from totalCollections to match PDF
        totalCollections: result.rows.length,
        completed: result.rows.filter(r => r.status === 'collected').length,
        missed: result.rows.filter(r => r.status === 'missed').length,
        pending: result.rows.filter(r => r.status === 'pending').length,
        completionRate: 0,
        wasteTypesHandled: new Set(result.rows.map(r => r.waste_type).filter(Boolean)).size,
        barangaysCovered: new Set(result.rows.map(r => r.barangay_name).filter(Boolean)).size,
        collectorsInvolved: new Set(result.rows.map(r => r.collector_id).filter(Boolean)).size,
        totalWasteAmount: result.rows.reduce((sum, row) => sum + parseFloat(row.amount || 0), 0)
      };

      if (summary.totalCollections > 0) {
        summary.completionRate = ((summary.completed / summary.totalCollections) * 100).toFixed(2);
      }

      // Waste type breakdown with percentages
      const wasteTypeBreakdown = {};
      const totalCollections = result.rows.length;
      
      result.rows.forEach(row => {
        const wasteType = row.waste_type || 'Mixed Waste';
        wasteTypeBreakdown[wasteType] = (wasteTypeBreakdown[wasteType] || 0) + 1;
      });

      // Add percentage calculation
      Object.keys(wasteTypeBreakdown).forEach(wasteType => {
        const count = wasteTypeBreakdown[wasteType];
        wasteTypeBreakdown[wasteType] = {
          count: count,
          percentage: totalCollections > 0 ? ((count / totalCollections) * 100).toFixed(1) : 0
        };
      });

      // Barangay breakdown
      const barangayBreakdown = {};
      result.rows.forEach(row => {
        const barangay = row.barangay_name || 'Unknown';
        barangayBreakdown[barangay] = (barangayBreakdown[barangay] || 0) + 1;
      });

      // Collector performance breakdown
      const collectorBreakdown = {};
      result.rows.forEach(row => {
        const collector = row.collector_name || `Collector ${row.collector_id}` || 'Unknown';
        if (!collectorBreakdown[collector]) {
          collectorBreakdown[collector] = { total: 0, completed: 0, missed: 0 };
        }
        collectorBreakdown[collector].total++;
        if (row.status === 'collected') collectorBreakdown[collector].completed++;
        if (row.status === 'missed') collectorBreakdown[collector].missed++;
      });

      const finalResult = {
        reportType: 'regular-pickup',
        summary,
        collections: result.rows,
        wasteTypeBreakdown,
        barangayBreakdown,
        collectorBreakdown,
        analytics: analyticsResult.rows,
        filters: filters,
        dateRange: { startDate: validStartDate, endDate: validEndDate },
        generatedAt: new Date().toISOString()
      };

      console.log('Waste collection report generated successfully');
      return finalResult;

    } catch (error) {
      console.error('=== WASTE COLLECTION REPORT ERROR ===');
      console.error('Error type:', error.constructor.name);
      console.error('Error message:', error.message);
      console.error('Error stack:', error.stack);
      throw error;
    }
  }

  // ðŸ’° BILLING/PAYMENT REPORT GENERATOR (REAL DATA)
  static async generateFinancialReport(filters = {}, startDate, endDate) {
    try {
      console.log('=== FINANCIAL REPORT ===');
      console.log('Filters:', filters);
      console.log('Start date:', startDate);
      console.log('End date:', endDate);

      // Validate dates
      const validStartDate = startDate && !isNaN(Date.parse(startDate)) ? startDate : '1900-01-01';
      const validEndDate = endDate && !isNaN(Date.parse(endDate)) ? endDate : '2100-12-31';

      // FIXED: Enhanced billing query with real data and safe joins
      let query = `
        SELECT 
          i.invoice_id,
          i.invoice_number,
          i.subscription_id,
          i.amount,
          i.status as invoice_status,
          i.generated_date,
          i.due_date,
          i.late_fees,
          i.notes,
          i.created_at,
          i.updated_at,
          DATE(i.generated_date) as billing_date,
          -- Calculate payment status
          CASE 
            WHEN i.status = 'paid' THEN 'Paid'
            WHEN i.status = 'unpaid' AND i.due_date < CURRENT_DATE THEN 'Overdue'
            WHEN i.status = 'unpaid' THEN 'Pending'
            ELSE UPPER(SUBSTRING(i.status, 1, 1)) || SUBSTRING(i.status, 2)
          END as payment_status_display,
          -- Get subscription and user info (with safe joins)
          COALESCE(cs.user_id, 0) as user_id,
          COALESCE(u.username, 'Unknown User') as resident_name,
          COALESCE(sp.plan_name, 'Unknown Plan') as plan_name,
          COALESCE(sp.price, 0) as plan_price,
          COALESCE(b.barangay_name, 'Unknown Barangay') as barangay_name,
          COALESCE(b.barangay_id, 0) as barangay_id
        FROM invoices i
        LEFT JOIN customer_subscriptions cs ON CAST(i.subscription_id AS INTEGER) = CAST(cs.subscription_id AS INTEGER)
        LEFT JOIN subscription_plans sp ON CAST(cs.plan_id AS INTEGER) = CAST(sp.plan_id AS INTEGER)
        LEFT JOIN users u ON CAST(cs.user_id AS INTEGER) = CAST(u.user_id AS INTEGER)
        LEFT JOIN addresses a ON CAST(u.address_id AS INTEGER) = CAST(a.address_id AS INTEGER)
        LEFT JOIN barangays b ON CAST(a.barangay_id AS INTEGER) = CAST(b.barangay_id AS INTEGER)
        WHERE 1=1
      `;

      const params = [];
      let paramCount = 0;

      // Apply date filters using actual invoice dates
      if (validStartDate && validEndDate) {
        paramCount += 2;
        query += ` AND DATE(i.generated_date) BETWEEN CAST($${paramCount-1} AS DATE) AND CAST($${paramCount} AS DATE)`;
        params.push(validStartDate, validEndDate);
      }

      // Apply barangay filter
      if (filters.barangay) {
        paramCount++;
        query += ` AND b.barangay_id = $${paramCount}::integer`;
        params.push(filters.barangay);
      }

      // Apply plan filter
      if (filters.plan) {
        paramCount++;
        query += ` AND sp.plan_id = $${paramCount}::integer`;
        params.push(filters.plan);
      }

      // Apply status filter
      if (filters.status && filters.status !== 'all') {
        paramCount++;
        query += ` AND i.status = $${paramCount}`;
        params.push(filters.status);
      }

      // Apply payment method filter
      if (filters.paymentMethod && filters.paymentMethod !== 'all') {
        paramCount++;
        query += ` AND i.payment_method = $${paramCount}`;
        params.push(filters.paymentMethod);
      }

      // Apply waste type filter (join with collection schedules to get waste type context)
      if (filters.wasteType && filters.wasteType !== '' && filters.wasteType !== 'all') {
        console.log('Applying waste type filter to billing report:', filters.wasteType);
        // Add join with collection_schedules to filter by waste type
        query = query.replace('WHERE 1=1', `
          LEFT JOIN collection_stop_events cse ON cse.user_id = cs.user_id 
            AND DATE(cse.created_at) BETWEEN DATE(i.generated_date) - INTERVAL '7 days' AND DATE(i.generated_date) + INTERVAL '7 days'
          LEFT JOIN collection_schedules sched ON CAST(cse.schedule_id AS TEXT) = CAST(sched.schedule_id AS TEXT)
          WHERE 1=1
        `);
        paramCount++;
        query += ` AND sched.waste_type ILIKE $${paramCount}`;
        params.push(`%${filters.wasteType}%`);
      }

      query += ` ORDER BY i.generated_date DESC`;

      console.log('Executing financial query:', query);
      console.log('Query params:', params);

      const result = await pool.query(query, params);
      console.log('Financial query result rows:', result.rows.length);

      // Calculate summary
      const invoices = result.rows;
      const summary = {
        totalInvoices: invoices.length,
        totalAmount: invoices.reduce((sum, inv) => sum + parseFloat(inv.amount || 0), 0),
        paidInvoices: invoices.filter(inv => inv.invoice_status === 'paid').length,
        unpaidInvoices: invoices.filter(inv => inv.invoice_status === 'unpaid').length,
        overdueInvoices: invoices.filter(inv => inv.invoice_status === 'overdue').length,
        paidAmount: invoices.filter(inv => inv.invoice_status === 'paid').reduce((sum, inv) => sum + parseFloat(inv.amount || 0), 0),
        unpaidAmount: invoices.filter(inv => inv.invoice_status === 'unpaid').reduce((sum, inv) => sum + parseFloat(inv.amount || 0), 0),
        collectionRate: 0
      };

      if (summary.totalAmount > 0) {
        summary.collectionRate = ((summary.paidAmount / summary.totalAmount) * 100).toFixed(2);
      }

      // Plan breakdown
      const planBreakdown = {};
      invoices.forEach(invoice => {
        const plan = invoice.plan_name || 'Unknown';
        if (!planBreakdown[plan]) {
          planBreakdown[plan] = { count: 0, totalAmount: 0, paidAmount: 0 };
        }
        planBreakdown[plan].count++;
        planBreakdown[plan].totalAmount += parseFloat(invoice.amount || 0);
        if (invoice.invoice_status === 'paid') {
          planBreakdown[plan].paidAmount += parseFloat(invoice.amount || 0);
        }
      });

      // Barangay breakdown
      const barangayBreakdown = {};
      invoices.forEach(invoice => {
        const barangay = invoice.barangay_name || 'Unknown';
        if (!barangayBreakdown[barangay]) {
          barangayBreakdown[barangay] = { count: 0, totalAmount: 0, paidAmount: 0 };
        }
        barangayBreakdown[barangay].count++;
        barangayBreakdown[barangay].totalAmount += parseFloat(invoice.amount || 0);
        if (invoice.invoice_status === 'paid') {
          barangayBreakdown[barangay].paidAmount += parseFloat(invoice.amount || 0);
        }
      });

      const finalResult = {
        reportType: 'billing-payment',
        summary,
        invoices: result.rows,
        planBreakdown,
        barangayBreakdown,
        filters: filters,
        dateRange: { startDate: validStartDate, endDate: validEndDate },
        generatedAt: new Date().toISOString()
      };

      console.log('Financial report generated successfully');
      return finalResult;
      
    } catch (error) {
      console.error('=== FINANCIAL REPORT ERROR ===');
      console.error('Error type:', error.constructor.name);
      console.error('Error message:', error.message);
      console.error('Error stack:', error.stack);
      throw error;
    }
  }

  // ðŸš› SPECIAL PICKUPS REPORT GENERATOR (COMPREHENSIVE)
  static async generateSpecialPickupsReport(filters = {}, startDate, endDate) {
    try {
      console.log('Generating Special Pickups Report with filters:', filters);
      
      // FIXED: Enhanced special pickups query with real data and safe joins
      let query = `
        SELECT 
          spr.request_id,
          spr.user_id,
          spr.waste_type,
          spr.description,
          spr.pickup_date,
          spr.pickup_time,
          spr.address as pickup_address,
          spr.notes,
          spr.image_url,
          spr.message,
          spr.status,
          spr.collector_id,
          spr.estimated_price,
          spr.final_price,
          spr.price_status,
          spr.created_at,
          spr.updated_at,
          DATE(spr.created_at) as request_date,
          -- Calculate response time
          CASE 
            WHEN spr.updated_at IS NOT NULL AND spr.created_at IS NOT NULL THEN
              EXTRACT(EPOCH FROM (spr.updated_at - spr.created_at))/3600
            ELSE 0
          END as response_time_hours,
          -- Get user and barangay info (with safe joins)
          COALESCE(u.username, 'Unknown User') as resident_name,
          COALESCE(b.barangay_name, 'Unknown Barangay') as barangay_name,
          COALESCE(b.barangay_id, 0) as barangay_id,
          -- Get collector info (with safe joins)
          COALESCE(u_collector.username, 'Unassigned') as collector_name
        FROM special_pickup_requests spr
        LEFT JOIN users u ON CAST(spr.user_id AS INTEGER) = CAST(u.user_id AS INTEGER)
        LEFT JOIN addresses a ON CAST(u.address_id AS INTEGER) = CAST(a.address_id AS INTEGER)
        LEFT JOIN barangays b ON CAST(a.barangay_id AS INTEGER) = CAST(b.barangay_id AS INTEGER)
        LEFT JOIN collectors c ON CAST(spr.collector_id AS INTEGER) = CAST(c.collector_id AS INTEGER)
        LEFT JOIN users u_collector ON CAST(c.user_id AS INTEGER) = CAST(u_collector.user_id AS INTEGER)
        WHERE 1=1
      `;
      
      const params = [];
      let paramCount = 0;
      
      // Validate dates
      const validStartDate = startDate && !isNaN(Date.parse(startDate)) ? startDate : '1900-01-01';
      const validEndDate = endDate && !isNaN(Date.parse(endDate)) ? endDate : '2100-12-31';

      // Apply comprehensive filters with proper type casting
      if (validStartDate && validEndDate) {
        paramCount += 2;
        query += ` AND DATE(spr.created_at) BETWEEN CAST($${paramCount-1} AS DATE) AND CAST($${paramCount} AS DATE)`;
        params.push(validStartDate, validEndDate);
      }
      
      // Apply barangay filter
      if (filters.barangay && filters.barangay !== '' && filters.barangay !== 'all') {
        console.log('Applying barangay filter:', filters.barangay, 'Type:', typeof filters.barangay);
        if (!isNaN(parseInt(filters.barangay))) {
          paramCount++;
          query += ` AND b.barangay_id = CAST($${paramCount} AS INTEGER)`;
          params.push(parseInt(filters.barangay));
        }
      }
      
      // Apply waste type filter
      if (filters.wasteType && filters.wasteType !== '' && filters.wasteType !== 'all') {
        console.log('Applying waste type filter:', filters.wasteType);
        paramCount++;
        query += ` AND spr.waste_type ILIKE $${paramCount}`;
        params.push(`%${filters.wasteType}%`);
      }
      
      // Apply status filter
      if (filters.status && filters.status !== 'all' && filters.status !== '') {
        console.log('Applying status filter:', filters.status);
        paramCount++;
        query += ` AND spr.status = $${paramCount}`;
        params.push(filters.status);
      }
      
      // Apply price status filter
      if (filters.priceStatus && filters.priceStatus !== '' && filters.priceStatus !== 'all') {
        console.log('Applying price status filter:', filters.priceStatus);
        paramCount++;
        query += ` AND spr.price_status = $${paramCount}`;
        params.push(filters.priceStatus);
      }
      
      // Apply collector filter
      if (filters.collector && filters.collector !== '' && filters.collector !== 'all') {
        console.log('Applying collector filter:', filters.collector, 'Type:', typeof filters.collector);
        if (!isNaN(parseInt(filters.collector))) {
          paramCount++;
          query += ` AND c.collector_id = CAST($${paramCount} AS INTEGER)`;
          params.push(parseInt(filters.collector));
        }
      }
      
      if (filters.minAmount) {
        paramCount++;
        query += ` AND spr.final_price >= $${paramCount}`;
        params.push(filters.minAmount);
      }
      
      if (filters.maxAmount) {
        paramCount++;
        query += ` AND spr.final_price <= $${paramCount}`;
        params.push(filters.maxAmount);
      }
      
      query += ` ORDER BY spr.pickup_date DESC, spr.created_at DESC`;
      
      const result = await pool.query(query, params);
      
      // Get waste type analytics
      const wasteTypeAnalyticsQuery = `
        SELECT 
          waste_type,
          COUNT(*) as request_count,
          AVG(final_price) as avg_price,
          SUM(final_price) as total_revenue,
          COUNT(CASE WHEN status = 'collected' THEN 1 END) as completed_count,
          ROUND(COUNT(CASE WHEN status = 'collected' THEN 1 END) * 100.0 / COUNT(*), 2) as completion_rate
        FROM special_pickup_requests
        WHERE pickup_date BETWEEN $1 AND $2
        GROUP BY waste_type
        ORDER BY request_count DESC
      `;
      
      const wasteTypeAnalyticsResult = await pool.query(wasteTypeAnalyticsQuery, [
        validStartDate, 
        validEndDate
      ]);
      
      // Calculate comprehensive summary
      const pickups = result.rows;
      const summary = {
        totalRequests: pickups.length,
        pending: pickups.filter(r => r.status === 'pending').length,
        inProgress: pickups.filter(r => r.status === 'in_progress').length,
        collected: pickups.filter(r => r.status === 'collected' || r.status === 'completed').length,
        cancelled: pickups.filter(r => r.status === 'cancelled').length,
        completionRate: 0,
        totalRevenue: pickups.reduce((sum, r) => sum + parseFloat(r.final_price || 0), 0),
        avgPrice: 0,
        avgResponseTimeHours: 0,
        avgCompletionDelayDays: 0,
        statusBreakdown: {
          pending: pickups.filter(r => r.status === 'pending').length,
          in_progress: pickups.filter(r => r.status === 'in_progress').length,
          collected: pickups.filter(r => r.status === 'collected').length,
          cancelled: pickups.filter(r => r.status === 'cancelled').length
        },
        priceStatusBreakdown: {
          pending: pickups.filter(r => r.price_status === 'pending').length,
          negotiating: pickups.filter(r => r.price_status === 'negotiating').length,
          agreed: pickups.filter(r => r.price_status === 'agreed').length
        },
        wasteTypeBreakdown: {},
        barangayBreakdown: {},
        collectorPerformance: {},
        monthlyTrends: {}
      };
      
      // Calculate rates and averages
      if (summary.totalRequests > 0) {
        summary.completionRate = ((summary.collected / summary.totalRequests) * 100).toFixed(2);
        
        const pricedPickups = pickups.filter(r => r.final_price > 0);
        if (pricedPickups.length > 0) {
          summary.avgPrice = (summary.totalRevenue / pricedPickups.length).toFixed(2);
        }
        
        const respondedPickups = pickups.filter(r => r.response_time_hours > 0);
        if (respondedPickups.length > 0) {
          summary.avgResponseTimeHours = (respondedPickups.reduce((sum, r) => sum + parseFloat(r.response_time_hours), 0) / respondedPickups.length).toFixed(1);
        }
        
        const completedPickups = pickups.filter(r => r.completion_delay_days !== null);
        if (completedPickups.length > 0) {
          summary.avgCompletionDelayDays = (completedPickups.reduce((sum, r) => sum + parseFloat(r.completion_delay_days || 0), 0) / completedPickups.length).toFixed(1);
        }
      }
      
      // Waste type breakdown
      pickups.forEach(pickup => {
        const wasteType = pickup.waste_type || 'Unknown';
        if (!summary.wasteTypeBreakdown[wasteType]) {
          summary.wasteTypeBreakdown[wasteType] = {
            totalRequests: 0,
            completed: 0,
            totalRevenue: 0,
            avgPrice: 0,
            completionRate: 0
          };
        }
        summary.wasteTypeBreakdown[wasteType].totalRequests++;
        summary.wasteTypeBreakdown[wasteType].totalRevenue += parseFloat(pickup.final_price || 0);
        if (pickup.status === 'collected') {
          summary.wasteTypeBreakdown[wasteType].completed++;
        }
      });
      
      // Calculate completion rates and avg prices for waste types
      Object.keys(summary.wasteTypeBreakdown).forEach(wasteType => {
        const breakdown = summary.wasteTypeBreakdown[wasteType];
        breakdown.completionRate = breakdown.totalRequests > 0 ? 
          ((breakdown.completed / breakdown.totalRequests) * 100).toFixed(2) : 0;
        breakdown.avgPrice = breakdown.completed > 0 ? 
          (breakdown.totalRevenue / breakdown.completed).toFixed(2) : 0;
      });
      
      // Barangay breakdown
      pickups.forEach(pickup => {
        const barangay = pickup.barangay_name || 'Unknown';
        if (!summary.barangayBreakdown[barangay]) {
          summary.barangayBreakdown[barangay] = {
            totalRequests: 0,
            completed: 0,
            totalRevenue: 0,
            completionRate: 0
          };
        }
        summary.barangayBreakdown[barangay].totalRequests++;
        summary.barangayBreakdown[barangay].totalRevenue += parseFloat(pickup.final_price || 0);
        if (pickup.status === 'collected') {
          summary.barangayBreakdown[barangay].completed++;
        }
      });
      
      // Calculate completion rates for barangays
      Object.keys(summary.barangayBreakdown).forEach(barangay => {
        const breakdown = summary.barangayBreakdown[barangay];
        breakdown.completionRate = breakdown.totalRequests > 0 ? 
          ((breakdown.completed / breakdown.totalRequests) * 100).toFixed(2) : 0;
      });
      
      // Collector performance
      pickups.forEach(pickup => {
        if (pickup.collector_username) {
          const collector = pickup.collector_username;
          if (!summary.collectorPerformance[collector]) {
            summary.collectorPerformance[collector] = {
              totalAssigned: 0,
              completed: 0,
              totalRevenue: 0,
              completionRate: 0,
              avgResponseTime: 0
            };
          }
          summary.collectorPerformance[collector].totalAssigned++;
          summary.collectorPerformance[collector].totalRevenue += parseFloat(pickup.final_price || 0);
          if (pickup.status === 'collected') {
            summary.collectorPerformance[collector].completed++;
          }
        }
      });
      
      // Calculate collector performance rates
      Object.keys(summary.collectorPerformance).forEach(collector => {
        const performance = summary.collectorPerformance[collector];
        performance.completionRate = performance.totalAssigned > 0 ? 
          ((performance.completed / performance.totalAssigned) * 100).toFixed(2) : 0;
      });
      
      // Monthly trends
      pickups.forEach(pickup => {
        const month = new Date(pickup.pickup_date).toISOString().slice(0, 7); // YYYY-MM
        if (!summary.monthlyTrends[month]) {
          summary.monthlyTrends[month] = {
            requestsReceived: 0,
            requestsCompleted: 0,
            totalRevenue: 0
          };
        }
        summary.monthlyTrends[month].requestsReceived++;
        summary.monthlyTrends[month].totalRevenue += parseFloat(pickup.final_price || 0);
        if (pickup.status === 'collected') {
          summary.monthlyTrends[month].requestsCompleted++;
        }
      });
      
      return {
        reportType: 'special-pickup',
        summary,
        pickups: result.rows,
        wasteTypeAnalytics: wasteTypeAnalyticsResult.rows,
        filters: filters,
        dateRange: { startDate: validStartDate, endDate: validEndDate },
        generatedAt: new Date().toISOString()
      };
      
    } catch (error) {
      console.error('Error generating special pickups report:', error);
      throw error;
    }
  }

  static async getBarangays(req, res) {
    try {
      const query = `SELECT barangay_id, barangay_name FROM barangays ORDER BY barangay_name`;
      const result = await pool.query(query);
      res.json(result.rows);
    } catch (error) {
      console.error('Error fetching barangays:', error);
      res.status(500).json({ error: 'Failed to fetch barangays', details: error.message });
    }
  }

  static async getCollectors(req, res) {
    try {
      const query = `
        SELECT c.collector_id, u.username
        FROM collectors c
        JOIN users u ON c.user_id = u.user_id
        ORDER BY u.username
      `;
      const result = await pool.query(query);
      res.json(result.rows);
    } catch (error) {
      console.error('Error fetching collectors:', error);
      res.status(500).json({ error: 'Failed to fetch collectors', details: error.message });
    }
  }

  static async getTrucks(req, res) {
    try {
      const query = `SELECT truck_id, truck_number FROM trucks ORDER BY truck_number`;
      const result = await pool.query(query);
      res.json(result.rows);
    } catch (error) {
      console.error('Error fetching trucks:', error);
      res.status(500).json({ error: 'Failed to fetch trucks', details: error.message });
    }
  }

  static async getSubdivisions(req, res) {
    try {
      const query = `SELECT subdivision_id, subdivision_name FROM subdivisions ORDER BY subdivision_name`;
      const result = await pool.query(query);
      res.json(result.rows);
    } catch (error) {
      console.error('Error fetching subdivisions:', error);
      res.status(500).json({ error: 'Failed to fetch subdivisions', details: error.message });
    }
  }

  static async getTeams(req, res) {
    try {
      const query = `
        SELECT DISTINCT 
          ca.assignment_id as team_id, 
          COALESCE(ca.shift_label, 'Team ' || ca.assignment_id) as team_name 
        FROM collector_assignments ca 
        WHERE ca.shift_label IS NOT NULL 
        ORDER BY team_name
      `;
      const result = await pool.query(query);
      res.json(result.rows);
    } catch (error) {
      console.error('Error fetching teams:', error);
      res.status(500).json({ error: 'Failed to fetch teams', details: error.message });
    }
  }

  static async getRoutes(req, res) {
    try {
      const query = `
        SELECT DISTINCT 
          rs.stop_id as route_id, 
          COALESCE(rs.planned_waste_type, 'Route ' || rs.stop_id) as route_name 
        FROM route_stops rs 
        WHERE rs.planned_waste_type IS NOT NULL 
        ORDER BY route_name
      `;
      const result = await pool.query(query);
      res.json(result.rows);
    } catch (error) {
      console.error('Error fetching routes:', error);
      res.status(500).json({ error: 'Failed to fetch routes', details: error.message });
    }
  }

  static async getPlans(req, res) {
    try {
      const query = `SELECT plan_id, plan_name FROM subscription_plans ORDER BY plan_name`;
      const result = await pool.query(query);
      res.json(result.rows);
    } catch (error) {
      console.error('Error fetching plans:', error);
      res.status(500).json({ error: 'Failed to fetch plans', details: error.message });
    }
  }

  static async getWasteTypes(req, res) {
    try {
      const query = `
        SELECT 
          ROW_NUMBER() OVER (ORDER BY waste_type) as waste_type_id,
          waste_type as waste_type_name 
        FROM (
          SELECT DISTINCT waste_type 
          FROM collection_schedules 
          WHERE waste_type IS NOT NULL
          UNION
          SELECT DISTINCT waste_type 
          FROM special_pickup_requests 
        ) wt
        ORDER BY waste_type_name
      `;
      const result = await pool.query(query);
      res.json(result.rows);
    } catch (error) {
      console.error('Error fetching waste types:', error);
      res.status(500).json({ error: 'Failed to fetch waste types', details: error.message });
    }
  }

  //  GENERATE PDF REPORT
  static async generatePDF(reportData, res) {
    try {
      const htmlPdf = require('html-pdf-node');
      
      // Generate HTML content for the report
      const htmlContent = ReportController.generateReportHTML(reportData);
      
      const options = {
        format: 'A4',
        border: {
          top: '0.5in',
          right: '0.5in',
          bottom: '0.5in',
          left: '0.5in'
        }
      };

      const file = { content: htmlContent };
      
      // Generate PDF
      const pdfBuffer = await htmlPdf.generatePdf(file, options);
      
      // Set response headers for PDF download
      const filename = `WSBS_Report_${reportData.type}_${reportData.report_id}_${new Date().toISOString().split('T')[0]}.pdf`;
      
      res.setHeader('Content-Type', 'application/pdf');
      res.setHeader('Content-Disposition', `attachment; filename="${filename}"`);
      res.setHeader('Content-Length', pdfBuffer.length);
      
      // Send PDF buffer
      res.send(pdfBuffer);
      
    } catch (error) {
      console.error('Error generating PDF:', error);
      res.status(500).json({ error: 'Failed to generate PDF', details: error.message });
    }
  }

  // ðŸŽ¨ GENERATE HTML TEMPLATE FOR PDF
  static generateReportHTML(reportData) {
    const { type, generated_by, date, period, data, report_id, start_date, end_date } = reportData;
    
    // Format report type for display
    const reportTypeDisplay = {
      'regular-pickup': 'Regular Pickup Report',
      'billing-payment': 'Billing & Payment Report', 
      'special-pickup': 'Special Pickup Report'
    }[type] || 'Report';

    // Generate summary section based on report type
    let summaryHTML = '';
    let detailTablesHTML = '';
    
    if (data && data.summary) {
      const summary = data.summary;
      
      if (type === 'regular-pickup') {
        summaryHTML = `
          <div class="summary-grid">
            <div class="summary-card">
              <h4>Total Schedules</h4>
              <p class="metric">${summary.totalSchedules || 0}</p>
            </div>
            <div class="summary-card">
              <h4>Completed</h4>
              <p class="metric">${summary.completed || 0}</p>
            </div>
            <div class="summary-card">
              <h4>Pending</h4>
              <p class="metric">${summary.pending || 0}</p>
            </div>
            <div class="summary-card">
              <h4>Completion Rate</h4>
              <p class="metric">${summary.completionRate || 0}%</p>
            </div>
          </div>
        `;

        // Add detailed tables for regular pickup
        if (data.collections && data.collections.length > 0) {
          detailTablesHTML += `
            <div class="section">
              <h3>ðŸ“‹ Collection Schedule Details</h3>
              <table class="data-table">
                <thead>
                  <tr>
                    <th>Schedule ID</th>
                    <th>Day</th>
                    <th>Waste Type</th>
                    <th>Time Range</th>
                    <th>Status</th>
                    <th>Created</th>
                  </tr>
                </thead>
                <tbody>
                  ${data.collections.slice(0, 20).map(item => `
                    <tr>
                      <td>${item.schedule_id}</td>
                      <td>${item.schedule_date}</td>
                      <td>${item.waste_type}</td>
                      <td>${item.time_range}</td>
                      <td><span class="status-${item.status}">${item.status}</span></td>
                      <td>${new Date(item.created_at).toLocaleDateString()}</td>
                    </tr>
                  `).join('')}
                </tbody>
              </table>
              ${data.collections.length > 20 ? `<p class="note">Showing first 20 of ${data.collections.length} total schedules</p>` : ''}
            </div>
          `;
        }

        // Add waste type breakdown
        if (data.wasteTypeBreakdown) {
          detailTablesHTML += `
            <div class="section">
              <h3>ðŸ—‚ï¸ Waste Type Breakdown</h3>
              <table class="data-table">
                <thead>
                  <tr>
                    <th>Waste Type</th>
                    <th>Count</th>
                    <th>Percentage</th>
                  </tr>
                </thead>
                <tbody>
                  ${Object.entries(data.wasteTypeBreakdown).map(([type, count]) => {
                    const percentage = summary.totalSchedules > 0 ? ((count / summary.totalSchedules) * 100).toFixed(1) : 0;
                    return `
                      <tr>
                        <td>${type}</td>
                        <td>${count}</td>
                        <td>${percentage}%</td>
                      </tr>
                    `;
                  }).join('')}
                </tbody>
              </table>
            </div>
          `;
        }
        
      } else if (type === 'billing-payment') {
        summaryHTML = `
          <div class="summary-grid">
            <div class="summary-card">
              <h4>Total Invoices</h4>
              <p class="metric">${summary.totalInvoices || 0}</p>
            </div>
            <div class="summary-card">
              <h4>Total Amount</h4>
              <p class="metric">â‚±${(summary.totalAmount || 0).toLocaleString()}</p>
            </div>
            <div class="summary-card">
              <h4>Collection Rate</h4>
              <p class="metric">${summary.collectionRate || 0}%</p>
            </div>
            <div class="summary-card">
              <h4>Paid Amount</h4>
              <p class="metric">â‚±${(summary.paidAmount || 0).toLocaleString()}</p>
            </div>
          </div>
        `;

        // Add detailed invoice table
        if (data.invoices && data.invoices.length > 0) {
          detailTablesHTML += `
            <div class="section">
              <h3>ðŸ’° Invoice Details</h3>
              <table class="data-table">
                <thead>
                  <tr>
                    <th>Invoice #</th>
                    <th>Customer</th>
                    <th>Plan</th>
                    <th>Amount</th>
                    <th>Status</th>
                    <th>Generated</th>
                    <th>Due Date</th>
                  </tr>
                </thead>
                <tbody>
                  ${data.invoices.slice(0, 15).map(invoice => `
                    <tr>
                      <td>${invoice.invoice_number || invoice.invoice_id}</td>
                      <td>${invoice.username || 'N/A'}</td>
                      <td>${invoice.plan_name || 'N/A'}</td>
                      <td>â‚±${parseFloat(invoice.amount || 0).toLocaleString()}</td>
                      <td><span class="status-${invoice.invoice_status}">${invoice.invoice_status}</span></td>
                      <td>${new Date(invoice.generated_date).toLocaleDateString()}</td>
                      <td>${new Date(invoice.due_date).toLocaleDateString()}</td>
                    </tr>
                  `).join('')}
                </tbody>
              </table>
              ${data.invoices.length > 15 ? `<p class="note">Showing first 15 of ${data.invoices.length} total invoices</p>` : ''}
            </div>
          `;
        }
        
      } else if (type === 'special-pickup') {
        summaryHTML = `
          <div class="summary-grid">
            <div class="summary-card">
              <h4>Total Requests</h4>
              <p class="metric">${summary.totalRequests || 0}</p>
            </div>
            <div class="summary-card">
              <h4>Completed</h4>
              <p class="metric">${summary.collected || 0}</p>
            </div>
            <div class="summary-card">
              <h4>Total Revenue</h4>
              <p class="metric">â‚±${(summary.totalRevenue || 0).toLocaleString()}</p>
            </div>
            <div class="summary-card">
              <h4>Avg Price</h4>
              <p class="metric">â‚±${summary.avgPrice || 0}</p>
            </div>
          </div>
        `;

        // Add special pickup details table
        if (data.pickups && data.pickups.length > 0) {
          detailTablesHTML += `
            <div class="section">
              <h3>ðŸš› Special Pickup Details</h3>
              <table class="data-table">
                <thead>
                  <tr>
                    <th>Request ID</th>
                    <th>Waste Type</th>
                    <th>Description</th>
                    <th>Pickup Date</th>
                    <th>Status</th>
                    <th>Final Price</th>
                  </tr>
                </thead>
                <tbody>
                  ${data.pickups.slice(0, 15).map(pickup => `
                    <tr>
                      <td>${pickup.request_id}</td>
                      <td>${pickup.waste_type}</td>
                      <td>${pickup.description ? pickup.description.substring(0, 50) + '...' : 'N/A'}</td>
                      <td>${new Date(pickup.pickup_date).toLocaleDateString()}</td>
                      <td><span class="status-${pickup.status}">${pickup.status}</span></td>
                      <td>â‚±${parseFloat(pickup.final_price || 0).toLocaleString()}</td>
                    </tr>
                  `).join('')}
                </tbody>
              </table>
              ${data.pickups.length > 15 ? `<p class="note">Showing first 15 of ${data.pickups.length} total requests</p>` : ''}
            </div>
          `;
        }
      }
    }

    return `
      <!DOCTYPE html>
      <html>
      <head>
        <meta charset="UTF-8">
        <title>WSBS ${reportTypeDisplay}</title>
        <style>
          body { font-family: Arial, sans-serif; margin: 20px; line-height: 1.4; }
          .header { background: #4CAF50; color: white; padding: 20px; text-align: center; margin-bottom: 20px; }
          .report-info { background: #f8f9fa; padding: 15px; margin-bottom: 20px; border-left: 4px solid #4CAF50; }
          .summary-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin-bottom: 30px; }
          .summary-card { background: white; border: 1px solid #ddd; padding: 15px; text-align: center; border-radius: 5px; }
          .metric { font-size: 24px; font-weight: bold; color: #4CAF50; }
          .section { margin-bottom: 30px; }
          .section h3 { color: #333; margin-bottom: 15px; padding-bottom: 5px; border-bottom: 2px solid #4CAF50; }
          .data-table { width: 100%; border-collapse: collapse; margin-top: 10px; font-size: 12px; }
          .data-table th, .data-table td { padding: 8px; text-align: left; border-bottom: 1px solid #ddd; }
          .data-table th { background-color: #f8f9fa; font-weight: bold; color: #333; }
          .data-table tr:nth-child(even) { background-color: #f9f9f9; }
          .status-completed, .status-paid { color: #28a745; font-weight: bold; }
          .status-pending { color: #ffc107; font-weight: bold; }
          .status-collected { color: #28a745; font-weight: bold; }
          .note { font-style: italic; color: #666; margin-top: 10px; font-size: 11px; }
          .footer { margin-top: 40px; text-align: center; color: #666; font-size: 12px; border-top: 1px solid #ddd; padding-top: 20px; }
        </style>
      </head>
      <body>
        <div class="header">
          <h1>WSBS - ${reportTypeDisplay}</h1>
          <p>Waste Scheduling and Billing System</p>
        </div>
        
        <div class="report-info">
          <p><strong>Report ID:</strong> #${report_id}</p>
          <p><strong>Generated By:</strong> ${generated_by}</p>
          <p><strong>Generated Date:</strong> ${date}</p>
          <p><strong>Period:</strong> ${period}</p>
          ${start_date ? `<p><strong>Date Range:</strong> ${start_date} to ${end_date}</p>` : ''}
        </div>
        
        <div class="section">
          <h3>ðŸ“Š Executive Summary</h3>
          ${summaryHTML}
        </div>
        
        ${detailTablesHTML}
        
        <div class="footer">
          <p>Generated by WSBS (Waste Scheduling and Billing System) on ${new Date().toLocaleString()}</p>
          <p>Â© 2024 WSBS. All rights reserved. | Report ID: #${report_id}</p>
        </div>
      </body>
      </html>
    `;
  }
}

module.exports = ReportController;
